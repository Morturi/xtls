import{_ as n,r as a,o as i,c as r,a as t,b as e,d as c,e as o}from"./app-Br3Hgc3R.js";const l={},p=o(`<h1 id="splithttp" tabindex="-1"><a class="header-anchor" href="#splithttp"><span>SplitHTTP</span></a></h1><p>Uses HTTP chunked-transfer encoding for download, and multiple HTTP requests for upload.</p><p>Can be deployed on CDNs that do not support WebSocket, but there are still some requirements:</p><ul><li><p>The CDN must support HTTP chunked transfer encoding in a streaming fashion, no response buffering. The transport will send the <code>X-Accel-Buffering: no</code> response header, but only some CDNs respect this.</p><p>If the connection hangs, most likely this part does not work.</p></li><li><p>The CDN must disable caching, or caching should include the query string in cache key.</p></li></ul><p>Download performance should be similar to WebSocket, but upload is limited.</p><p>Like WebSocket transport, SplitHTTP parses the <code>X-Forwarded-For</code> header for logging.</p><h2 id="splithttpobject" tabindex="-1"><a class="header-anchor" href="#splithttpobject"><span>SplitHttpObject</span></a></h2><p>The <code>SplitHttpObject</code> corresponds to the <code>splithttpSettings</code> section under transport configurations.</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;path&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;host&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xray.com&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;headers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;value&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>path</code>: string</p></blockquote><p>HTTP path used by the connection. Defaults to <code>&quot;/&quot;</code>.</p><blockquote><p><code>host</code>: string</p></blockquote><p>HTTP Host sent by the connection. Empty by default. If this value is empty on the server, the host header sent by clients will not be validated.</p><p>If the <code>Host</code> header has been defined on the server in any way, the server will validate if the <code>Host</code> header matches.</p><p>The current priority of the <code>Host</code> header sent by clients: <code>host</code> &gt; <code>headers</code> &gt; <code>address</code></p><blockquote><p><code>headers</code>: map {string: string}</p></blockquote><p>Customized HTTP headers defined in key-value pairs. Defaults to empty.</p><blockquote><p><code>maxUploadSize</code></p></blockquote><p>The largest possible chunk to upload. Defaults to 1 MB. This should be less than the max request body size your CDN allows. Decrease this if the client prints HTTP 413 errors. Increase this to improve upload bandwidth.</p><blockquote><p><code>maxConcurrentUploads</code></p></blockquote><p>The number of concurrent uploads to run. Defaults to 10. Connections are reused wherever possible, but you may want to lower this value if the connection is unstable, or if the server is using too much memory.</p><p>The value on the client must not be higher than on the server. Otherwise, connectivity issues will occur.</p><h2 id="known-issues" tabindex="-1"><a class="header-anchor" href="#known-issues"><span>Known issues</span></a></h2><ul><li>ALPN negotiation is currently not correctly implemented. HTTPS connections always assume HTTP/2 prior knowledge.</li></ul><h2 id="protocol-details" tabindex="-1"><a class="header-anchor" href="#protocol-details"><span>Protocol details</span></a></h2>`,25),d={href:"https://github.com/XTLS/Xray-core/pull/3412",target:"_blank",rel:"noopener noreferrer"},u=o("<ol><li><p><code>GET /?session=UUID</code> starts a new &quot;virtual&quot; stream connection. The server immediately responds with <code>200 OK</code> and <code>Transfer-Encoding: chunked</code>, and immediately sends a two-byte payload to force HTTP middleboxes into flushing headers.</p></li><li><p>Once the client has read all of this, it can start uploading using <code>POST /?session=UUID?seq=0</code>. <code>seq</code> can be used like TCP seq number, and multiple &quot;packets&quot; may be sent concurrently. The server has to reassemble the &quot;packets&quot; live. The sequence number never resets for simplicity reasons.</p></li><li><p>The <code>GET</code> request is kept open until the tunneled connection has to be terminated. Either server or client can close. How this actually works depends on the HTTP version.</p></li></ol><p>Recommendations:</p><ul><li><p>Do not assume any custom headers are transferred correctly by the CDN. This transport is built for CDN who do not support WebSocket, these CDN tend to not be very modern (or good).</p></li><li><p>It should be assumed there is no streaming upload within a HTTP request, so the size of a packet should be chosen to optimize between latency, throughput, and any size limits imposed by the CDN (just like TCP, nagle&#39;s algorithm and MTU...)</p></li></ul>",3);function h(m,b){const s=a("ExternalLinkIcon");return i(),r("div",null,[p,t("p",null,[e("See "),t("a",d,[e("PR"),c(s)]),e(" for extensive discussion and revision of the protocol. Here is a summary, and the minimum needed to be compatible:")]),u])}const f=n(l,[["render",h],["__file","splithttp.html.vue"]]);export{f as default};
