[{"uri":"https://xtls.github.io/en/documents/level-0/ch01-preface/","title":"【第1章】前言啰嗦篇","tags":[],"description":"小小白白话文","content":"1.1 这篇文档是写给谁的？  一句话：写给 ①零基础 ②希望学习自建VPS 的新人。\n 1.2 这篇文档不是写给谁的？  包括但不限于：各路大神大能、懒得自己折腾的小白、已经会折腾的高手、确定要用机场的土豪、确定要用一键脚本的逍遥派\u0026hellip;\u0026hellip; 总之只要有技术基础、或不愿不想自建的同学，您直接关闭本文即可，因为这篇文章大概是入不了您的法眼的，更可能会让您生一肚子闲气，那多划不来。\n 1.3 郑重声明及其他声明  郑重声明：\n鄙人技术奇菜无比，故本文必然挂一漏万破绽百出。您若发现问题还请温柔提醒，莫要人参公鸡。\n 免责声明：\n本文内容请您自行判断是否可信可靠可用，若您根据本文内容建立和使用VPS服务器时出了任何问题和不良结果，鄙人概不负责。\n 啰嗦声明：\n基于本文【零基础用户】的目标受众，许多内容会尽力详尽说明，所以语言偏啰嗦，请做好心理准备。\n  1.4 为什么自建是个难题？  要回答这个问题，就需要稍微多说一点背景信息了。\n一、科学上网这件事\n科学上网这件事情，说来已经发展了近二十年（震惊!!!.jpg）。最初，自己稍微动动手即可（改改host、连一下ssh）、后来需要找一个网页代理，再后来需要写一个私有协议(比如Shadowsocks)等等。\n随着GFW技术这十几年来不断的迭代升级，若要完成【自己动手科学上网】这个目标，需要做的事情已经包括但不限于：\n1. 了解Linux系统基本命令 2. 了解网络传输协议 3. 有技术和经济能力完成VPS购买及管理 4. 有技术和经济能力完成域名购买及管理 5. 有技术能力完成TLS证书申请 等等。  这就让【自建VPS科学上网】这个曾经简单的行为逐渐变成了令新人望而生畏的挑战。\n二、零基础用户的无奈\n零基础的非技术用户，如果完成上面这一连串的操作，势必要学习大量的知识，但稍微搜索之后，新人只怕会更加迷茫：大量的信息散布在互联网的各个角落：博客、问答网站、群组、论坛、GitHub、Telegram、YouTube 等等等等）。这些信息纷乱复杂、水平良莠不齐、甚至可能互相矛盾。基本上就是不把新人彻底弄晕誓不罢休。\n面对这些杂乱无章的信息，新人突然就从【信息匮乏】变成了【信息过剩】。若是几番连蒙带猜的折腾以失败告终（大概率如此）的话，他的积极性势必大受挫折。在这个过程中，若他又恰好去了一些不太友好的地方去求助，恐怕还要雪上加霜的被嘲讽一番：“这么菜，用机场不就行了，瞎折腾什么啊！”、“先去学会Linux再回来问吧”。\n这时候，大概也只有一声“呵呵”可以表达心情了。\n 1.5 “用机场不就行了？”  首先，我想反问一下那些冷嘲热讽的人：“用机场”真的就是万灵药吗？\n其次，我认为“不懂”和“不想懂”是有本质区别的。态度恶劣的巨婴伸手党自然惹人厌烦，但真心自学却不得要领的人不该受到无端的白眼和歧视，也正是这种对新人不加区分的恶劣社区氛围促使我写下本文。那么闲话少说，我们来看看机场的优势与劣势究竟如何：\n一、“机场“的优势\n所谓“机场”，就是“线路提供商”。他负责完成1.4提到的那一串技术操作和管理，用户则付费获得使用权。所以，它的优点至少有：\n 用户操作简单：扫码操作、一键添加规则等 线路选择多：可解锁不同国家、地区的网络服务；比如iplc等专线服务、游戏加速服务等 接入节点多：所以抵抗节点封锁的能力强一些，封了一个就换下一个  二、“机场”的风险\n“方便”这枚硬币的另一面就是“风险”，基于“机场”的技术特点和市场情况，它的风险至少有：\n “机场”可完全获得用户信息：用户在网上的所有痕迹，都【必然】经过且【非常可能】长期存储在其服务器上，这些记录无法受到任何具备法律效力的用户隐私协议的约束（窥视、记录你的一举一动） “机场”缺乏市场管理：不可避免存在着以欺诈为目标的恶意商家（主动跑路） “机场”面临监管压力：大机场相对有保障的同时，也无法避免树大招风。2020年间，已经有几个大机场停运、跑路的事件发生，用户的正常使用受到严重干扰（被动跑路） “机场”技术水平难以确定：线路质量良莠不齐，挂羊头卖狗肉的现象屡见不鲜（速度慢、掉线多、连不上）   1.6 那么你到底要不要自建呢？  现在，你已经看到了机场的优势和风险，要用什么，就请各位充分思考并自行决定。毕竟，最适合你的方案才是最好的方案。\n  如果决定使用机场的话，现在，你可以关闭本文了。\n  如果你决定自建，那就请继续阅读后面的章节吧！！\n  总之，本文的目标就是成为零基础用户的知识起点，提供对每一步充分的讲解和演示，清清楚楚（甚至婆婆妈妈、絮絮叨叨、啰啰嗦嗦）的协助新人完成【从输入第一条命令开始，完成VPS服务器部署，并成功在客户端完成科学上网】的全程。并在这个过程中帮助新人逐步接触和熟悉Linux的基础操作，为之后的进一步自学打下基础。\n 1.7 题外啰嗦几句    墙外的信息泥沙俱下，请务必学会理性、独立的思辨，不要随意站队，不要轻信猎奇的信息。\n  衷心希望大家获得更顺畅的网络后，可以获取更新鲜的知识、更丰富的娱乐、接触更美好的世界、结交更多志同道合的朋友，但不要成为任何有不可告人目的之人的替罪羊。\n  你的互联网身份依然是你的身份，绝对的匿名化是极为困难的，所以请务必遵守你个人所在地区和IP所在地区的相关法律法规。无论何时，自我保护都是最基本的底线。\n   1.8 你的进度  PROGRESS⬛⬜⬜⬜⬜⬜⬜⬜ 12.5%\n "},{"uri":"https://xtls.github.io/en/config/outbound-protocols/blackhole/","title":"Blackhole","tags":[],"description":"Project X 的文档.","content":"Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由配置 一起使用，可以达到禁止访问某些网站的效果。\nOutboundConfigurationObject  { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  response: ResponseObject\n 配置黑洞的响应数据。\nBlackhole 会在收到待转发数据之后，发送指定的响应数据，然后关闭连接，待转发的数据将被丢弃。 如不指定此项，Blackhole 将直接关闭连接。\n\nResponseObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;http\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 当 type 为 \u0026quot;none\u0026quot;（默认值）时，Blackhole 将直接关闭连接。\n当 type 为 \u0026quot;http\u0026quot; 时，Blackhole 会发回一个简单的 HTTP 403 数据包，然后关闭连接。\n"},{"uri":"https://xtls.github.io/en/documents/level-2/transparent_proxy/transparent_proxy/","title":"Getting Started with Transparent Proxy","tags":[],"description":"Project X Documentation.","content":"What is Transparent Proxy(TProxy)? General speaking the Transparent Proxy is not let the device which has been proxied feeling itself to be proxied, further speaking is the proxied device do not need to run any proxy software(such as Xray, V2rayNG and so on). When you connected to the network, your device has been proxied.\nAnd it means that, the proxy software is running in other places, such as running in the router, all the devices connected to the Internet via the router can automatically be proxied.\nImplementation of Transparent Proxy Now the implementation of transparent proxy has two ways:\ntun2socks It can be implemented on Windows/Linux (including Android). Because the implementation process is relatively simple and there are few tutorials, I will briefly describe it here.\nWindows\n  Install Netch , Using mode[3] [TUN/TAP] Bypass LANand active it.\n  Turn on the Hotspot\n  OpenControl Panel-\u0026gt;Networok and Internet-\u0026gt;Network and Sharing Center-\u0026gt;Change adapter settings, findTAP-Windows AdapterandMicrosoft Wi-Fi Direct Virtual Adapter.\n  Right ClickTAP-Windows Adapter, Properties-\u0026gt;Sharing, CheckAllow other network users to connect through this computer’s Internet connection, select the network connection of Microsoft Wi-Fi Direct Virtual Adapter in Home Network Connection, and click OK.\n  Android\n  Configure connection V2RayNG\n  Open Hotspot\n  Hotspot settings -\u0026gt; Allow Hotspot use VPN(partly Android may not have this option)\n  iptables/nftables iptables \u0026amp; nftables are the same way to implemented Transparent Proxy, and the following uses iptables uniformly.\nThe Transparent Proxy which based on iptables only available in Linux system(concluding Openwrt/Android). For its more efficiency than tun2socks and it is suitable on router, make it be widely used.\nThe existing three vernacular transparent proxy tutorials actually talk about this transparent proxy implementation based on this scheme, they are: New V2Ray vernacular tutorials-Transparent Proxy , New V2Ray vernacular tutorials-TPROXY , Tproxy Configuration . And the first article is based on iptables-redirect mode, but is outdated and not recommended for use, only reference. The second and third articles talk about the implementation of transparent proxy based on iptables-tproxy mode.\niptables implement the principle of transparent proxy Linux use Netfilter to manage network, the Netfilter model is as follows:\nAssuming that a router is used as a gateway (that is, our usual way of surfing the Internet), then:\nThe traffic direction of LAN devices accessing the Internet through the router:\nPREROUTING CHAIN-\u0026gt;FORWARD CHAIN-\u0026gt;POSTINGROUTING CHAIN\nLAN device to access the router traffic (such as login router web management interface / ssh connection router / access dns servers of router, etc.) direction:\nPREROUTING CHAIN-\u0026gt;INPUT CHAIN-\u0026gt;Gateway native\nThe direction of traffic from the router access to the Internet:\nGateway Native-\u0026gt;OUTPUT CHAIN-\u0026gt;POSTINGROUTING CHAIN\nBy using iptables to manipulate the traffic direction of PREROUTING CHAIN and OUTPUT CHAIN, and forward it to Xray, it can proxy LAN equipment and gateway native.\nWhere is the difficulty of transparent proxy? The difficulty of transparent proxy lies in routing. The so-called routing is to distinguish which traffic is directly connected and which should be proxied, so I personally think that it is more appropriate to call it Diversion.\nWe can divide routing from easy to difficult into the following stages:\n  Proxy all the requests.\n  Local LAN IP / Multicast IP request direct connection, others request proxy.\n  Directly connect the connection request which initiated by Xray on the basic of the second point.\n  On the basis of the third point, directly connect to the connection request pointing to the IP in mainland China, and select the domestic and foreign DNS server to resolve the domestic and foreign domain names.\n  The three tutorials mentioned above are all in the fourth stage. So it may seem a bit difficult to understand for novices to read directly.\nStep by step implementation of transparent proxy based on iptables-tproxy from zero Before the start, you need to have certain basic knowledge:   You need to know about TCP/IP protocol, domain name and DNS server.\n  Know what is WAN port, LAN port, LAN_IP, WAN_IP and DHCP server. For the bypass route, there is only one network port, which is called the LAN port here\n  Have the most basic understanding of the Linux system (know how to run commands)\n  Be able to write the client json file configuration, and at least the configuration can be understood.\n  Initial Preparation Work 1. Prepare a gateway running Linux system\nFor example, a router with OpenWRT.\n2. Prepare Xray executable files and configuration files at the gateway (router)\nThe configuration file monitors port 12345 and enables tproxy:\n{ \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { The configuration of your server } ] } We start from easy to difficult. Without writing routing, we only write one inbound and one outbound.\nFirst, let’s try to do the first stage Forward all traffic of the PREROUTING CHAIN to Xray.\nRun Xray and execute the following commands:\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY After you have entered, if you use ssh to connect to the gateway, you will find that the ssh is disconnected (don’t worry, it can be restored after power off and restart), and the transparent proxy cannot access the Internet; if your gateway is Virtual machine, you will find that the gateway itself cannot access the Internet, and there will appear many requests about the source address as the destination address and the destination address as WAN_IP in the access_log of Xray.\nTheoretically, the gateway\u0026rsquo;s local access to the public network will only go through the OUTPUT CHAIN and POSTROUTING CHAIN. Why does manipulation of the PREROUTING CHAIN cause the gateway to fail to access the Internet? This is because network communication is often two-way. Although the gateway does not need to pass through the PREROUTING CHAIN to access the public IP, the accessed server return information to the gateway must pass through the PREROUTING CHAIN, and this part is forwarded to Xray. Therefore, a reverse request in the log appears.\nLet\u0026rsquo;s modify the rules. If the source IP is not from LAN, and then return. Restart the gateway, run Xray, and execute the following commands:\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY # \u0026#34;Gateway LAN_IP address segment\u0026#34; obtained by running the command \u0026#34;ip address | grep -w \u0026#34;inet\u0026#34; | awk\u0026#39;{print $2}\u0026#39;\u0026#34;, is one of them iptables -t mangle -A XRAY ! -s Gateway LAN_IP address segment -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY Then you will find that although the ssh connection is broken, the transparent proxy is already available. As long as modify the system dns to public dns, we will be able to access the Internet (because the gateway cannot be accessed now, so set dns to the gateway will not work).\nAt this point, the first stage is finished. The reason why the gateway cannot be accessed is that the proxy rules proxy all the traffic, including the traffic which access to the gateway. Imagine accessing your local gateway on the VPS, it is definitely not accessible. So we need to connect this part of traffic directly. Please read the second stage:\nSecond stage Restart the gateway, run Xray, and execute the following commands:\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY # All the target address at network segment where the gateway is located request direct connection # Obtained by running the command \u0026#34;ip address | grep -w \u0026#34;inet\u0026#34; | awk\u0026#39;{print $2}\u0026#39;\u0026#34;, generally there are multiple iptables -t mangle -A XRAY -d Network segment 1 where the gateway is located -j RETURN iptables -t mangle -A XRAY -d Network segment 2 where the gateway is located -j RETURN ... # Request direct connection when the destination address is multicast IP iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY After using this rule, the previous rule iptables -t mangle -A XRAY ! -s Gateway LAN_IP address segment -j RETURN becomes a redundant rule and can be deleted.\nAt this point, the second stage is completed. The gateway is already accessible, and ssh will not be disconnected.\nThe third stage The DNS we usually use comes from routers, but this iptables rule only proxies the devices in the local area network, but does not proxy the gateway native, so the returned DNS query results may be wrong or polluted.\niptables-tproxy do not support OUTPUT CHAIN operation, but Netfilter has a feature, after marking the packet as 1 at OUTPUT CHAIN , the corresponding packet will be rerouted to the PREROUTING CHAIN. Therefore, the request that the gateway native needs to proxy, we can mark 1 at OUTPUT CHAIN .\nIf you want to proxy all the requests sent by the gateway native, it will introduce a problem, Xray runs on the gateway, Xray sends a request to the proxy server, and the request is proxied again, will form a loop.\nTherefore, to proxy the gateway native, it is necessary to avoid loopback happening, that is, to circumvent Xray request traffic in proxy rules.\nThere are three common methods:\n Directly connect to the traffic which target address to VPS  Restart the gateway, run Xray, and execute the following commands:\n#Proxy LAN Device #Inherit the results of the previous stage ip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 iptables -t mangle -N XRAY iptables -t mangle -A XRAY -d Network segment 1 where the gateway is located -j RETURN iptables -t mangle -A XRAY -d Network segment 2 where the gateway is located -j RETURN ... iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY #Proxy Gateway Native iptables -t mangle -N XRAY_MASK iptables -t mangle -A XRAY_MASK -d Network segment 1 where the gateway is located -j RETURN iptables -t mangle -A XRAY_MASK -d Network segment 2 where the gateway is located -j RETURN ... iptables -t mangle -A XRAY_MASK -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_MASK -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY_MASK -d VPS Public IP/32 -j RETURN iptables -t mangle -A XRAY_MASK -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -p tcp -j XRAY_MASK iptables -t mangle -A OUTPUT -p udp -j XRAY_MASK But to configure like this has a disadvantage. If you use CDN or have a lot of VPS, it is hard to write rules.\nCircumvent through Mark  The three vernacular tutorials all use this method to circumvent, and refer it by yourself, so I won\u0026rsquo;t repeat them here.\nCircumvent through gid (recommended)  Reference [TProxy]Avoid Xray traffic through gid\nThis completes the third stage agent, which is usually called the global agent. But remember to set the DNS server of the gateway to a foreign DNS server, otherwise the polluted results may still be returned.\nFourth stage In fact, not everyone needs to achieve the fourth stage. The global proxy is already applicable for most situations.\nEspecially for bypass routes. When proxy is required, adjust the gateway to the bypass route IP, and when proxy is not required, change the gateway back to the main route IP.\nAs for the specific realization of the fourth stage, refer to the three vernacular tutorials. After understanding the above content, reading the three vernacular tutorials will be easier to understand.\nProxy ipv6 The above rules only take effect for ipv4. If you want to proxy ipv6 requests, use the ip6tables command, which is basically the same as iptables. Refer to [TProxy]Avoid Xray traffic through gid#4-set iptables rules\nOther considerations for transparent proxy of iptables   If the gateway which perform as a proxy is used as the main route, add a iptables -t mangle -A XRAY ! -s Gateway LAN_IP address segment -j RETURN to the PREROUTING CHAIN rule, these are the commands that used in the first stage and deleted in the second stage. If you don\u0026rsquo;t write it, other people on the same network segment in the WAN port can fill in the gateway which is your WAN_IP, for stealing your transparent proxy to use, it may also bring a certain degree of danger.\n  The third article in New V2Ray vernacular guide-Transparent Proxy(TPROXY)#Setting Gateway says: Manually configure the network of PC and point the default gateway to the address of the Raspberry Pi, which is 192.168.1.22. At this time, the PC should be able to access the Internet normally (because no proxy has been set up yet, \u0026quot;normally\u0026quot; means that the domestic website can be accessed). In fact, even if IP forwarding is turned on in Ubuntu, CentOS, debian and other systems, the PC cannot access the Internet, this is normal. In fact, only OpenWRT can achieve as described in the text. According to @BioniCosmos remind, this is because the general Linux system does not have Masquery rules.\n  The Problem of \u0026ldquo;Too many open files\u0026rdquo; , Refer the solution to [TProxy]Avoid Xray traffic through gid-Configure the maximum file opening number \u0026amp; Run Xray client\n  Regarding enable the ip_forward, to be added\u0026hellip;\n  To prevent the existing connected package from passing through TPROXY twice, to be added\u0026hellip;\n  Main routing, single-arm routing and bypass routing, to be added\u0026hellip;\n  "},{"uri":"https://xtls.github.io/en/config/transports/tcp/","title":"TCP","tags":[],"description":"Project X 的文档.","content":"TCP 传输模式是目前推荐使用的传输模式之一.\n可以和各种协议有多种组合模式.\nTcpObject  TcpObject 对应传输配置的 tcpSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\n默认值为 false。\nheader: NoneHeaderObject | HttpHeaderobject\n 数据包头部伪装设置，默认值为 NoneHeaderObject。\nTIP\nHTTP 伪装无法被其它 HTTP 服务器（如 Nginx）分流，但可以被 VLESS fallbacks path 分流。\n \nNoneHeaderObject  不进行伪装\n{ \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: \u0026ldquo;none\u0026rdquo;\n 指定不进行伪装\n\nHttpHeaderObject  HTTP 伪装配置必须在对应的入站出站连接上同时配置，且内容必须一致。\n{ \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;request\u0026#34;: {}, \u0026#34;response\u0026#34;: {} }  type: \u0026ldquo;http\u0026rdquo;\n 指定进行 HTTP 伪装\nrequest: HTTPRequestObject\n HTTP 请求\nresponse: HTTPResponseObject\n HTTP 响应\n\nHTTPRequestObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;GET\u0026#34;, \u0026#34;path\u0026#34;: [\u0026#34;/\u0026#34;], \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: [\u0026#34;www.baidu.com\u0026#34;, \u0026#34;www.bing.com\u0026#34;], \u0026#34;User-Agent\u0026#34;: [ \u0026#34;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36\u0026#34;, \u0026#34;Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46\u0026#34; ], \u0026#34;Accept-Encoding\u0026#34;: [\u0026#34;gzip, deflate\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nmethod: string\n HTTP 方法，默认值为 \u0026quot;GET\u0026quot;。\npath: [ string ]\n 路径，一个字符串数组。默认值为 [\u0026quot;/\u0026quot;]。当有多个值时，每次请求随机选择一个值。\nheaders: map{ string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n\nHTTPResponseObject  { \u0026#34;version\u0026#34;: \u0026#34;1.1\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;OK\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: [\u0026#34;application/octet-stream\u0026#34;, \u0026#34;video/mpeg\u0026#34;], \u0026#34;Transfer-Encoding\u0026#34;: [\u0026#34;chunked\u0026#34;], \u0026#34;Connection\u0026#34;: [\u0026#34;keep-alive\u0026#34;], \u0026#34;Pragma\u0026#34;: \u0026#34;no-cache\u0026#34; } }  version: string\n HTTP 版本，默认值为 \u0026quot;1.1\u0026quot;。\nstatus: string\n HTTP 状态，默认值为 \u0026quot;200\u0026quot;。\nreason: string\n HTTP 状态说明，默认值为 \u0026quot;OK\u0026quot;。\nheaders: map {string, [ string ]}\n HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。\n每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。\n"},{"uri":"https://xtls.github.io/en/develop/protocols/vless/","title":"VLESS 协议","tags":[],"description":"Project X 的文档.","content":"VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\nIn progress\n"},{"uri":"https://xtls.github.io/en/faq/start/","title":"下载和安装中的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我想自己下载安装包, 可是release好多文件, 我要下载哪一个呢?请先使用谷歌搜索您的设备型号, 确认您设备使用的架构, 然后下载对应的版本.  Q: 我在VPS上运行了脚本, 好像安装好了, 可是似乎没反应?/系统服务不能启动?/我也不知道有没有安装成功?使用命令 \u0026lsquo;journalctl -u xray\u0026rsquo; 查看 xray 的相关日志。\n或者\n终端命令行中执行 \u0026lsquo;xray run -c 您的config.json文件路径\u0026rsquo; 来查看相关信息\n Q: 配置文件在哪个目录。谢谢!这位同学你可真的是不看文档, 不过因为你很有礼貌, 我可以告诉你在这里有所有文件的安装位置\n "},{"uri":"https://xtls.github.io/en/documents/level-0/","title":"小小白白话文","tags":[],"description":"小小白白话文","content":" 这个章节是【从零开始】的基础课，新来的同学好好看好好学哦 Made with ❤️ by @ricuhkaen\n  【第1章】 前言罗嗦篇 - 机场还是自建？这是个问题\n【第2章】 原料准备篇 - 工欲善其事，必先利其器\n【第3章】 远程登录篇 - 一桥飞架南北，天堑变通途\n【第4章】 安全防护篇 - 安全不注意，亲人两行泪\n【第5章】 网站建设篇 - 秀出你的美\n【第6章】 证书管理篇 - 领证的才是合法的\n【第7章】 Xray服务器篇 - 终于等到你 \n【第8章】 Xray客户端篇 - 新的开始 \n【第9章】 附录 - 考点都在这里 \n "},{"uri":"https://xtls.github.io/en/develop/intro/","title":"开发手册","tags":[],"description":"Project X 的文档.","content":" 如果您想帮助 Xray 开发, 请详细阅读本章节中的内容 编译 Xray 支持各种平台, 您可以在多种平台上自行进行交叉编译.\n请点击编译以查看具体编译相关内容\n 设计思路 Xray 内核提供了一个平台，在其之上可以进二次开发 这个章节阐述了Xray的设计目标和架构.\n请点击设计思路以了解Xray的设计目标和架构.\n 开发规范 这个章节阐述了获取代码,进行开发,提交PR的流程中需要遵循的准则, 以及相关的编码规范\n请点击开发规范查看Xray开发中应遵循的准则.\n  \n协议详解 Xray 用到了很多种协议, 您可以通过各种途径获得协议的详细描述.\n请点击协议详解以查看相关协议的详细剖析\n  "},{"uri":"https://xtls.github.io/en/config/base/log/","title":"日志配置","tags":[],"description":"Project X 的文档.","content":"日志配置，控制 Xray输出日志的方式.\nXray 有两种日志, 访问日志和错误日志, 你可以分别配置两种日志的输出方式.\nLogObject  LogObject 对应配置文件的 log 项。\n{ \u0026#34;log\u0026#34;: { \u0026#34;access\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;文件地址\u0026#34;, \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; } }  access: string\n 访问日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/access.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_access.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 access log。  error: string\n 错误日志的文件地址，其值是一个合法的文件地址，如\u0026quot;/var/log/Xray/error.log\u0026quot;（Linux）或者\u0026quot;C:\\\\Temp\\\\Xray\\\\_error.log\u0026quot;（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。\n 特殊值none，即关闭 error log。  loglevel: \u0026ldquo;debug\u0026rdquo; | \u0026ldquo;info\u0026rdquo; | \u0026ldquo;warning\u0026rdquo; | \u0026ldquo;error\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n error 日志的级别, 指示 error 日志需要记录的信息. 默认值为 \u0026quot;warning\u0026quot;。\n \u0026quot;debug\u0026quot;：调试程序时用到的输出信息。同时包含所有 \u0026quot;info\u0026quot; 内容。 \u0026quot;info\u0026quot;：运行时的状态信息等，不影响正常使用。同时包含所有 \u0026quot;warning\u0026quot; 内容。 \u0026quot;warning\u0026quot;：发生了一些并不影响正常运行的问题时输出的信息，但有可能影响用户的体验。同时包含所有 \u0026quot;error\u0026quot; 内容。 \u0026quot;error\u0026quot;：Xray 遇到了无法正常运行的问题，需要立即解决。 \u0026quot;none\u0026quot;：不记录任何内容。  "},{"uri":"https://xtls.github.io/en/develop/intro/compile/","title":"编译","tags":[],"description":"Project X 的文档.","content":"前序工作  Xray 使用 Golang 作为主要编程语言。\n 下载 Golang: Downloads 安装 Golang: install  important请使用 Golang 1.15 以上版本。\n \n编译  拉取 Xray 源代码和依赖  在安装了git的环境下, 只需要执行以下命令即可clone一份完整的Xray-core代码:\ngit clone https://github.com/XTLS/Xray-core.git \n注意事项  在无法正常访问 Google 的网络环境，依赖可能无法被正常拉取，可以通过各种手段代理解决.\n比如可以通过设置 GOPROXY：\ngo env -w GOPROXY=https://goproxy.io,direct \n手工编译  important本小节的命令需要在 Xray 项目根目录内运行。\n 在 Linux 环境下, 只需执行以下命令, 即可在当前目录下生成刚构建的 xray 可执行文件。\nCGO_ENABLED=0 go build -o xray -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main 如果需要编译可以进行debug的程序,即可以用dlv附加到运行的程序进行调试, 请去掉 ldflags 中的 \u0026lsquo;-w -s\u0026rsquo; 选项.\nTIP\n-w 禁止生成debug信息,注意使用该选项后，无法使用 gdb 进行调试\n-s 禁用符号表\nPS:其实用vscode调试似乎更方便.\n \n交叉编译  构建其他 CPU 架构、其他系统（Windows/macOS）的可执行文件需要设置 GOOS 和 GOARCH 两个环境变量为目标平台/架构.\n可以参考 Golang 相关文档 比如Building Windows Go programs on Linux。\n如下面代码即可以构建可运行在 Windows 64 位系统的 xray.exe 可执行文件：\nCGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -o xray.exe -trimpath -ldflags \u0026#34;-s -w -buildid=\u0026#34; ./main  TIP\n执行 go tool dist list 可以查看所有支持的系统与架构。 某些架构还需要控制其它环境变量，如 arm 的 GOARM，用于设置运行时 CPU 浮点协处理器的版本。\n "},{"uri":"https://xtls.github.io/en/about/new/","title":"X History","tags":[],"description":"Project X Documentation","content":"2021.01.25  Have you practiced the best and most detailed documentation in the Internet? Mr.🍉 started writting the level 1 secret script\u0026hellip; The English version of the documentation website is gradually being added, thanks to the hard work of all of you!  2021.01.22 v1.2.3   Support for the SS protocol has been enhanced again. It supports the use of multiple users on a single port now! Support for the trojan protocol has been enhanced again, and we have a new way in trojan fallbacks to separate traffic using SNI~! _(VLESS: Nyaaaaaa~~)_ The weird UDP bug has been solved, one word \u0026ldquo;stable\u0026rdquo;! Sniffing can exclude domains you don\u0026rsquo;t want to sniff, and you will get some new approaches in this area. Salution to the big shot who finds the problem -\u0026gt; opens an issue -\u0026gt; tests it himself -\u0026gt; analyzes it himself -\u0026gt; finds the problem himself -\u0026gt; solves it himself -\u0026gt; then submits a PR to upstream and downstream @Bohan Yang! There are also other delicious little cherries, just update to taste them as usual.  2021.01.19  Some numbers  10 released tags 100 solved issues 300 forks 2,000 stars 3,000 people in chat group    2021.01.17  The hard translation work has begun, thanks to @玖柒Max and all the big shots who translate. English version  \n2021.01.15 v1.2.2   A strange new pose has been unlocked for fallback triage! You can now divide your data based on SNI in your fallbacks~! The previously previewed UUID modifications are now live. (scroll down to see) The logs now look a little smoother than they did last time. The remote DOH has learned to walk by triage just like the rest of the DNS schema. And of course all the other little sweets. (Just update the tasting) Ah, and by the way, the first man in the world to run xray on M1 was Anthony TSE  2021.01.12   The UUID to come will be modified to support mapping between custom strings and UUIDs. This means you will be able to write ids to correspond to users in the configuration file like this.  Configuration of the client: \u0026quot;id\u0026quot;: \u0026quot;I will always love Mr.🍉\u0026quot; Configuration of the server: \u0026quot;id\u0026quot;: \u0026quot;9017f6ef-7fa9-5afb-a6b4-76648028f1a4\u0026quot; (this UUID is the UUID map of I will always love Mr.🍉)   Mr.🍉's level 0 documentation is finally over, clap clap!  \n2021.01.10   The level 0 documentation are now online. They are the result of teacher🍉's hard work, teaching you how to go from nothing to xray proficiency! (Probably the most detailed and patient tutorial on the entire internet that teaches you how to configure from scratch) Many articles have also been added to the transparent proxy series. There are still a lot of details to change, and the documentation will become more and more standardised! Thanks to @ricuhkaen , @BioniCosmos, @kirin.  v1.2.1   Lots of UDP-related fixes, and you can even play Rainbow Six on Ubisoft\u0026rsquo;s potato servers! Google Voice should also work properly with v2rayNG dialing. Logs now look much better.  \n2021.01.07   Courtesy and respect should have been one of the guidelines that the community did not need to explicitly state.  \n2021.01.05   The documentation site is quietly undergoing some mysterious changes.🙊🙊🙊  \n2021.01.03   The first PR of the document repository.🎉\nTransparent proxy (TProxy) configuration tutorial ，thanks to @BioniCosmos The number of people in the tg group exceeds 2,500.  \n2021.01.01  [Happy new year to everyone, 新年快乐！]🎆🎇🎆\nv1.2.0  In the final minutes of New Year\u0026rsquo;s Day, v1.2.0 it came, as is customary with Friday updates, and with the efforts of all the contributors and the dark eye circles of @rprxx, it\u0026rsquo;s here to live up to people\u0026rsquo;s expectation!\n New Year\u0026rsquo;s presents after Christmas presents v1.1.5, big benefits for gamers, full FullCone. (UDP functionality will continue to be enhanced!) If you\u0026rsquo;ve already opened your Christmas presents, this time there\u0026rsquo;s something even better than Christmas presents, with wrapping and little sweets. (Again, don\u0026rsquo;t ask, just update and taste) (No, it\u0026rsquo;s not an ad below, it\u0026rsquo;s a milestone.) Xray is the first ever unrestricted multi-protocol platform: just xray solves the problem, no need to borrow from other implementations.  One person carries it all! Support for all major protocols! Unbeatable performance! Increasingly sophisticated functionality! Fearless vitality and community affinity!   Xray will keep on going! So xray needs more heroes! PS: Please savor, please savor every sentence of release notes. There seems to be a little surprise. (Ah, there\u0026rsquo;s a knock on the door\u0026hellip; I\u0026rsquo;ll talk to you guys later)  \n2020.12.29 Hello transparent proxy gamers! Xray-core tproxy inbound, socks outbound and UDP FullCone beta are being tested in the telegram group\n\n2020.12.25  Merry Christmas!\nv1.1.5   A Christmas present for gamers! You can now play games with xray! Because now there is SS/trojan UDP fullcone You can now write configuration files in your preferred format, like yaml, like toml\u0026hellip; (UDP fullcone and more enhancements for VLESS coming soon! Don\u0026rsquo;t worry about certificate validation domains being banned, OCSP stapling is now live! kirin has brought many script updates. Scripts here And more delicious little cherries! (Don\u0026rsquo;t ask, just update to taste)  \n2020.12.24 For some indescribable reason, xray\u0026rsquo;s documentation site has been sneaked online ahead of the release date.\nThe url is: yes that\u0026rsquo;s what you\u0026rsquo;re looking at\nYou can check out the various contents and feel free to correct/suggest (you can post to the issue section of the documentation github repository)\nThe documentation site needs constant refinement and addition of content, as well as refinement of the design. So all are more than welcome to contribute to the documentation. Repository of documents\nThere is a short tutorial in the repository readme on how to help xray improve the documentation site. \u0026lt;br Feel free to check it out, correct errors, make changes and add ideas.\n\n2020.12.23 Xray-core Shadowsocks UDP FullCone beta, is being tested in the telegram group.\n\n2020.12.21   More than 2,000 members in Project X group. Group messages (including the game group) average over 10,000 per day.   2020.12.18  v1.1.4   Lower in-boot footprint and memory usage optimisation Arbitrarily configurable TLS to improve your SSL rating Splice with XTLS inbound support and XTLS with trojan support And advice on the best usage patterns for splice on your router  \n2020.12.17  In view a growing group size and demand for games, the telegram games group has been opened.\n\n2020.12.15  The dev branch of the installation script is open, and is being continuously updated.\n\n2020.12.11  v1.1.3   Full version of redirect transparent proxy mode. Suggested optimisation of the soft route splice flow control mode.  \n2020.12.06  v1.1.2   Splice mode added to flow control, available only on Linux, for unparalleled performance. Enhanced API compatibility.  \n2020.12.04  Add splice mode.\n\n2020.11.27   Project X\u0026rsquo;s GitHub master repository Xray-core has received 500+ stars Featured on GitHub Trending Project X has over 1,000 group members and 500+ channel subscribers  \n2020.11.25  v1.0.0  The first version of xray.\n Based on v2ray-core, with significant changes. Fully enhanced, excellent performance, fully compatible.  \n2020.11.23  Project X started.\n"},{"uri":"https://xtls.github.io/en/guide/install/","title":"Download and install","tags":[],"description":"Project X Documents","content":"Platform support  Xray is available in the following platforms.\n Windows 7 and later (x86 / amd64 / arm32). macOS 10.10 Yosemite and later (amd64). Linux 2.6.23 and later (x86 / amd64 / arm / arm64 / mips64 / mips / ppc64 / s390x / riscv64).  Including but not limited to Debian 7 / 8, Ubuntu 12.04 / 14.04 and later, CentOS 7 / 8, Arch Linux, etc.   FreeBSD (x86 / amd64). OpenBSD (x86 / amd64). Dragonfly BSD (amd64).  \nDownload xray  The pre-compiled binary ZIP archive can be found at Github Releases.\nDownload the zip file for your platform, unzip it and you are ready to use it.\n\nVerify the installation package  Xray provides two types of validation.\n ZIP archive with SHA1 / SHA256 digest: In progress Reproducible build: In progress  \nInstallation methods for Windows  Download the ZIP archive for Windows from Github Releases, unzip it to get the executable xray.exe, and then run it with parameters via the command line. Install via Scoop package manager: In progress Install via Chocolatey package manager: In progress  \nInstallation methods for macOS  Download the ZIP archive for Windows from Github Releases, unzip it to get the executable xray.exe, and then run it with parameters via the command line. Install via Homebrew package manager: brew install xray  \nInstallation methods for Linux  Installation scripts    Linux Script\n Xray-install Xray-script    One Click\n ProxySU Xray-agent    Magisk\n Xray4Magisk Xray_For_Magisk    Package managers for Linux releases  Xray packages for Linux releases (can be installed via the release\u0026rsquo;s corresponding package manager).\n Debian：In progress Arch Linux：In progress  Brew package manager  In progress\n\nInstallation as Docker   teddysun/xray Xray-docker  File structure of the Docker image   /etc/xray/config.json：Configuration files /usr/bin/xray：Xray host program /usr/local/share/xray/geoip.dat：IP data file /usr/local/share/xray/geosite.dat：Domain name data file  \nMore and more\u0026hellip;  You can click on the portal to the many big man\u0026rsquo;s gathering area for more resources.\nFAQ In progress\n"},{"uri":"https://xtls.github.io/en/about/","title":"Project X","tags":[],"description":"Project X Documents","content":" Project X originates from XTLS protocol, provides a set of network tools such as Xray-core and Xray-flutter.\n Xray-core is a superset of v2ray-core with a range of enhancements including better overall performance and XTLS, and is fully compatible with v2ray-core\u0026rsquo;s features and configuration.  Only one executable file with ctl function, run is the default command. The configuration is fully compatible and the environment variables and APIs should be changed to start with XRAY_. ReadV with bare protocol is open across the platform. Provides full VLESS \u0026amp; Trojan XTLS support, both with ReadV. XTLS offers multiple flow control modes for unparalleled performance! \u0026ldquo;Configurations are compatible and better overall\u0026rdquo;\n    Xray-flutter is an elegant cross-platform GUI tool.In progress   Developers   It doesn’t matter who we are. What matters is that we will keep riding and not look back. Help xray become stronger  Welcome to help make xray stronger!\n 🖥️ Help develop and test xray, submitting high quality pull requests. 📩 Start a constructive or meaningful issue/discussion on gitHub issues or discussion forum. 📝 Write down your experiences and submit them to xray\u0026rsquo;s documentation site. 💬 Help/chat in Telegram groups. \u0026hellip;In fact, every bit of positive energy given to xray makes it stronger!   Telegram    Project X Exchange Group\n In the exchange group you can talk as much as you want within the limits, no tearing up, no abuse of rights. If you have any questions, feel free to ask them and try to answer them if you know. NSFW or political content is prohibited.    Project X Channel\n Release of the latest information on Project X     Thanks   Thanks to everyone for their support! Thanks to all the scripts, Docker images, client support\u0026hellip; Thanks to all the contributors who helped make the xray ecosystem better! Thank you to all those who have contributed to the xray website and documentations. Thank you to all those who made meaningful suggestions and comments. Thanks to everyone in the telegram group who helped out.   License  Mozilla Public License Version 2.0 Stargazers over time  Project X’s main GitHub repository, xray-core, has received nearly 2,000 stars; the Project X group has reached 2,500 and the channel has 1,000 subscribers\n\n"},{"uri":"https://xtls.github.io/en/documents/level-0/ch02-preparation/","title":"【第2章】原料准备篇","tags":[],"description":"小小白白话文","content":"这一章比较特殊，因为涉及到金钱交易行为，本文基于项目的中立立场，不做具体的推荐。我能做的，是告诉你需要准备哪些东西。\n2.1 获取一台VPS  你需要获取一台健康的、IP没有被墙的VPS，并在管理后台做下面这些基础准备：\n 在VPS的后台安装 Debian 10 64bit 系统 小本本记下VPS的IP地址（本文会用 \u0026quot;100.200.300.400\u0026quot; 来表示） 注意： 这是一个故意写错的非法IP，请替换成你的真实IP）\n  小本本记下VPS的SSH远程登陆端口(Port) 小本本记下SSH远程登录的用户名和密码  购买VPS是一个比较复杂的事情，建议先去学习一下相关知识，选择适合自己的经济能力和线路需求的即可。另外可以选择薅一些国际大厂的羊毛（比如甲骨文和谷歌提供的永久免费或限时免费的套餐）。总之，务必量力而行。\n说明： 关于选择 Debian 10 作为操作系统，这里稍微多说一句：不管你在网上听说了什么，不管哪个大神告诉你XXX版的Linux更好、XXX版的Linux更牛，这些Linux的派系之争跟现在的你半毛钱关系也没有！使用 Debian 10 足以让你的VPS服务器在安全、稳健运行的同时得到足够的优化（如cloud专用内核、及时的bbr支持等）。等你对Linux熟悉之后，再回头去尝试其他的Linux发行版也不迟\n  2.2 获取一个心仪的域名  你需要获取一个域名、并在DNS设置中添加一条A记录，指向你VPS的IP地址\n  请选择靠谱的国际域名服务商。选择一些常见的域名后缀就行，注意不要用 .cn 后缀。\n  在DNS设置中，添加一条指向你VPS的IP地址的A记录（A记录的名字可以随便起，本文会用 \u0026quot;a-name\u0026quot; 来表示。完整的域名则会用 \u0026quot;二级域名.你的域名.com\u0026quot; 或者 \u0026quot;a-name.yourdomain.com\u0026quot; 来表示）。效果如下图：\n注意： 这不是一个真实可用的网址，请替换成你的真实网址\n    2.3 你本地电脑上需要安装的软件    SSH远程登录工具\n Windows: PuTTY macOS/Linux: Terminal    远程文件拷贝工具\n Windows: WinSCP macOS/Linux: Terminal    靠谱的文本编辑器\n Windows/macOS/Linux: VSCode     2.4 你的进度  如果上面的原材料你都准备好了的话，你已经拿到了开启新世界大门的钥匙。那还等什么，然我们快点进入下一章，走进这扇门吧！\nPROGRESS⬛⬛⬜⬜⬜⬜⬜⬜ 25%\n "},{"uri":"https://xtls.github.io/en/config/base/api/","title":"API interfaces","tags":[],"description":"Project X Documents","content":"The API interface configuration provides a number of gRPC-based API interfaces for remote calls.\nThe interface can be opened via the api configuration module. When api configuration is enabled, xray will create its own outbound proxy to which all inbound API connections must be manually routed via Routing rules.\nPlease refer to the [related configurations](#Related configurations) in this section.\nMost users will not use this API and newcomers can simply ignore it.\n ApiObject  ApiObject corresponds to the api entry in the configuration file.\n{ \u0026#34;api\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;services\u0026#34;: [ \u0026#34;HandlerService\u0026#34;, \u0026#34;LoggerService\u0026#34;, \u0026#34;StatsService\u0026#34; ] } }  tag: string\n Outbound agent tag.\nservices: [string]\n List of open APIs, check [API list](# Supported-api-lists). for optional values.\n\nRelated configurations  You can add an api\u0026rsquo;s inbound to the inbounds configuration.\n\u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 10085, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;tag\u0026#34;: \u0026#34;api\u0026#34; } ] Add routing rules for api inbound in the routing configuration.\n\u0026#34;routing\u0026#34;: { \u0026#34;settings\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;inboundTag\u0026#34;: [ \u0026#34;api\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34; } ] }, \u0026#34;strategy\u0026#34;: \u0026#34;rules\u0026#34; } \nSupported-api-lists  HandlerService Some of the APIs that are available for modifications to inbound and outbound agents are\n Adding a new inbound agent. Adding a new outbound agent. Removing an existing inbound agent. deleting an existing outbound agent. adding a user to an inbound agent. (only VMess, VLESS, Trojan, Shadowsocks (v1.3.0+) are supported) deleting a user from an inbound agent. (only VMess, VLESS, Trojan, Shadowsocks (v1.3.0+) are supported)  LoggerService Support for restarting the built-in Logger, which can be used in conjunction with logrotate for some log file manipulation.\nStatsService Built-in statistical services, see Statistical Information for details.\n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/dns/","title":"DNS","tags":[],"description":"Project X 的文档.","content":"DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。\n此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。\n在处理 DNS 查询时，此出站协议会将 IP 查询（即 A 和 AAAA）转发给内置的 DNS 服务器。其它类型的查询流量将被转发至它们原本的目标地址。\nOutboundConfigurationObject  { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;1.1.1.1\u0026#34;, \u0026#34;port\u0026#34;: 53 }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo;\n 修改 DNS 流量的传输层协议，可选的值有 \u0026quot;tcp\u0026quot; 和 \u0026quot;udp\u0026quot;。当不指定时，保持来源的传输方式不变。\naddress: address\n 修改 DNS 服务器地址。当不指定时，保持来源中指定的地址不变。\nport: number\n 修改 DNS 服务器端口。当不指定时，保持来源中指定的端口不变。\n\nDNS配置实例  In progress\n"},{"uri":"https://xtls.github.io/en/config/inbound-protocols/dokodemo/","title":"Dokodemo door","tags":[],"description":"Project X 的文档.","content":"Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。\nInboundConfigurationObject  { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;timeout\u0026#34;: 0, \u0026#34;followRedirect\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  address: address\n 将流量转发到此地址。可以是一个 IP 地址，形如 \u0026quot;1.2.3.4\u0026quot;，或者一个域名，形如 \u0026quot;xray.com\u0026quot;。字符串类型。\n当 followRedirect（见下文）为 true 时，address 可为空。\nport: number\n 将流量转发到目标地址的指定端口，范围 [1, 65535]，数值类型。必填参数。\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\ntimeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300。处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\nfollowRedirect: true | false\n 当值为 true 时，dokodemo-door 会识别出由 iptables 转发而来的数据，并转发到相应的目标地址。\n可参考 传输配置 中的 tproxy 设置。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n透明代理配置样例  此部分请参考透明代理（TProxy）配置教程。\n"},{"uri":"https://xtls.github.io/en/documents/level-1/","title":"Getting Started Skills","tags":[],"description":"Project X Documentation.","content":" This chapter is an entry-level Xray experience sharing, if you want to master Xray use skills, you can start here  Working mode of Xray\n This article introduces the two basic working modes and basic principles of Xray.\n"},{"uri":"https://xtls.github.io/en/documents/level-2/tproxy/","title":"TProxy Configuration","tags":[],"description":"Project X Documentation.","content":"This configuration is based on New V2Ray vernacular tutorial on TProxy (transparent proxy) , adding the new features of Xray, using the VLESS + XTLS Splice solution, and change the default outbound proxy distribution method to the default outbound direct connection in the old tutorial, the user should modify it according to the actual situation.\nAll the configurations in this article have been successfully tested in Raspberry Pi 2B and Ubuntu 20.04 environments. If you use them in other environments, please adjust the configuration yourself.\nBefore the Start Please check if your device has an available network connection, and the server has been configured successfully, the client has been installed.\nIt should be noticed that many transparent proxy tutorials currently open the IP forwarding of the Linux system, but this will cause the performance decreasing of Splice. For details, please refer to Chapter 3 \u0026ldquo;Record of solving the Big case\u0026rdquo;\u0026ndash;How we cracked the mystery of Splice performance degradation even lower than Direct performance.\nWhat I want to add here is that many transparent proxy tutorials will use Netfilter to diverse traffic, so that direct traffic is sent directly without going through Xray. At this time, IP forwarding must be enabled; And some tutorials, such as this article, will import all traffic into Xray. And then Xray\u0026rsquo;s routing module performs traffic distribution, and there is no need to enable IP forwarding at this time.\nConfiguration of Xray { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, \u0026#34;error\u0026#34;: \u0026#34;/var/log/xray/error.log\u0026#34;, \u0026#34;access\u0026#34;: \u0026#34;/var/log/xray/access.log\u0026#34; }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;all-in\u0026#34;, \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34; ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;UseIPv4\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } }, { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;Server Domain\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;UUID\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-splice\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34; } ] } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } }, { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;response\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;http\u0026#34; } } }, { \u0026#34;tag\u0026#34;: \u0026#34;dns-out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;dns\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;8.8.8.8\u0026#34; }, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34; }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 2 } } } ], \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;Server Domain\u0026#34;: \u0026#34;Server IP\u0026#34; }, \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;119.29.29.29\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, { \u0026#34;address\u0026#34;: \u0026#34;223.5.5.5\u0026#34;, \u0026#34;port\u0026#34;: 53, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, \u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34;, \u0026#34;https+local://doh.dns.sb/dns-query\u0026#34; ] }, \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPIfNonMatch\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;all-in\u0026#34; ], \u0026#34;port\u0026#34;: 53, \u0026#34;outboundTag\u0026#34;: \u0026#34;dns-out\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;119.29.29.29\u0026#34;, \u0026#34;223.5.5.5\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;1.1.1.1\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:jp\u0026#34;, \u0026#34;geoip:us\u0026#34;, \u0026#34;geoip:sg\u0026#34;, \u0026#34;geoip:hk\u0026#34;, \u0026#34;geoip:tw\u0026#34;, \u0026#34;109.239.140.0/24\u0026#34;, \u0026#34;14.102.250.18\u0026#34;, \u0026#34;14.102.250.19\u0026#34;, \u0026#34;149.154.164.0/22\u0026#34;, \u0026#34;149.154.168.0/22\u0026#34;, \u0026#34;149.154.172.0/22\u0026#34;, \u0026#34;174.142.105.153\u0026#34;, \u0026#34;50.7.31.230\u0026#34;, \u0026#34;67.220.91.15\u0026#34;, \u0026#34;67.220.91.18\u0026#34;, \u0026#34;67.220.91.23\u0026#34;, \u0026#34;69.65.19.160\u0026#34;, \u0026#34;72.52.81.22\u0026#34;, \u0026#34;85.17.73.31\u0026#34;, \u0026#34;91.108.4.0/22\u0026#34;, \u0026#34;91.108.56.0/22\u0026#34;, \u0026#34;91.108.56.0/23\u0026#34;, \u0026#34;108.177.120.94\u0026#34;, \u0026#34;108.177.120.0/24\u0026#34;, \u0026#34;172.217.0.0/16\u0026#34;, \u0026#34;74.125.0.0/16\u0026#34;, \u0026#34;23.246.0.0/18\u0026#34;, \u0026#34;37.77.184.0/21\u0026#34;, \u0026#34;45.57.0.0/17\u0026#34;, \u0026#34;64.120.128.0/17\u0026#34;, \u0026#34;66.197.128.0/17\u0026#34;, \u0026#34;108.175.32.0/20\u0026#34;, \u0026#34;192.173.64.0/18\u0026#34;, \u0026#34;198.38.96.0/19\u0026#34;, \u0026#34;198.45.48.0/20\u0026#34;, \u0026#34;173.245.48.0/20\u0026#34;, \u0026#34;103.21.244.0/22\u0026#34;, \u0026#34;103.22.200.0/22\u0026#34;, \u0026#34;103.31.4.0/22\u0026#34;, \u0026#34;141.101.64.0/18\u0026#34;, \u0026#34;108.162.192.0/18\u0026#34;, \u0026#34;190.93.240.0/20\u0026#34;, \u0026#34;188.114.96.0/20\u0026#34;, \u0026#34;197.234.240.0/22\u0026#34;, \u0026#34;198.41.128.0/17\u0026#34;, \u0026#34;162.158.0.0/15\u0026#34;, \u0026#34;104.16.0.0/12\u0026#34;, \u0026#34;172.64.0.0/13\u0026#34;, \u0026#34;131.0.72.0/22\u0026#34;, \u0026#34;144.220.0.0/16\u0026#34;, \u0026#34;52.124.128.0/17\u0026#34;, \u0026#34;54.230.0.0/16\u0026#34;, \u0026#34;54.239.128.0/18\u0026#34;, \u0026#34;52.82.128.0/19\u0026#34;, \u0026#34;99.84.0.0/16\u0026#34;, \u0026#34;204.246.172.0/24\u0026#34;, \u0026#34;54.239.192.0/19\u0026#34;, \u0026#34;70.132.0.0/18\u0026#34;, \u0026#34;13.32.0.0/15\u0026#34;, \u0026#34;205.251.208.0/20\u0026#34;, \u0026#34;13.224.0.0/14\u0026#34;, \u0026#34;13.35.0.0/16\u0026#34;, \u0026#34;204.246.164.0/22\u0026#34;, \u0026#34;204.246.168.0/22\u0026#34;, \u0026#34;71.152.0.0/17\u0026#34;, \u0026#34;216.137.32.0/19\u0026#34;, \u0026#34;205.251.249.0/24\u0026#34;, \u0026#34;99.86.0.0/16\u0026#34;, \u0026#34;52.46.0.0/18\u0026#34;, \u0026#34;52.84.0.0/15\u0026#34;, \u0026#34;204.246.173.0/24\u0026#34;, \u0026#34;130.176.0.0/16\u0026#34;, \u0026#34;205.251.200.0/21\u0026#34;, \u0026#34;204.246.174.0/23\u0026#34;, \u0026#34;64.252.128.0/18\u0026#34;, \u0026#34;205.251.254.0/24\u0026#34;, \u0026#34;143.204.0.0/16\u0026#34;, \u0026#34;205.251.252.0/23\u0026#34;, \u0026#34;204.246.176.0/20\u0026#34;, \u0026#34;13.249.0.0/16\u0026#34;, \u0026#34;54.240.128.0/18\u0026#34;, \u0026#34;205.251.250.0/23\u0026#34;, \u0026#34;52.222.128.0/17\u0026#34;, \u0026#34;54.182.0.0/16\u0026#34;, \u0026#34;54.192.0.0/16\u0026#34;, \u0026#34;103.2.30.0/23\u0026#34;, \u0026#34;125.209.208.0/20\u0026#34;, \u0026#34;147.92.128.0/17\u0026#34;, \u0026#34;203.104.144.0/21\u0026#34;, \u0026#34;91.108.8.0/22\u0026#34;, \u0026#34;91.108.12.0/22\u0026#34;, \u0026#34;91.108.16.0/22\u0026#34;, \u0026#34;149.154.160.0/20\u0026#34;, \u0026#34;3.123.36.126/32\u0026#34;, \u0026#34;35.157.215.84/32\u0026#34;, \u0026#34;35.157.217.255/32\u0026#34;, \u0026#34;52.58.209.134/32\u0026#34;, \u0026#34;54.93.124.31/32\u0026#34;, \u0026#34;54.162.243.80/32\u0026#34;, \u0026#34;54.173.34.141/32\u0026#34;, \u0026#34;54.235.23.242/32\u0026#34;, \u0026#34;169.45.248.118/32\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; } ] } }  TIPs\nThis configuration will hijack all traffic sent to port 53 to solve the DNS pollution problem, so the address of the client and the local DNS server address of this machine can be configured at will.\nIn addition, because the built-in geoip.dat file cannot perfectly implement routing traffic diverse, some addon IPs are added to the configuration file.\n Policy Routing Configuration # ip route add local default dev lo table 100 # Add routing table 100 # ip rule add fwmark 1 table 100 # Set rules for routing table 100 Configuration of Netfilter Notices\nChoose one of nftables configuration and iptables configuration, and cannot be used two at the same time.\n nftables #!/usr/sbin/nft -f flush ruleset\ndefine RESERVED_IP = { 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, 169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 224.0.0.0/4, 240.0.0.0/4, 255.255.255.255/32 }\ntable ip xray { chain prerouting { type filter hook prerouting priority mangle; policy accept; ip daddr $RESERVED_IP return ip daddr 192.168.0.0/16 tcp dport != 53 return ip daddr 192.168.0.0/16 udp dport != 53 return ip protocol tcp tproxy to 127.0.0.1:12345 meta mark set 1 ip protocol udp tproxy to 127.0.0.1:12345 meta mark set 1 } chain output { type route hook output priority mangle; policy accept; ip daddr $RESERVED_IP return ip daddr 192.168.0.0/16 tcp dport != 53 return ip daddr 192.168.0.0/16 udp dport != 53 return meta mark 2 return ip protocol tcp meta mark set 1 ip protocol udp meta mark set 1 } } Instructions\nWrite the above configuration into a file (such as nft.conf), then grant the file executable permissions, and finally execute the file with root permissions（# ./nft.conf）.\n iptables iptables -t mangle -N XRAY iptables -t mangle -A XRAY -d 10.0.0.0/8 -j RETURN iptables -t mangle -A XRAY -d 100.64.0.0/10 -j RETURN iptables -t mangle -A XRAY -d 127.0.0.0/8 -j RETURN iptables -t mangle -A XRAY -d 169.254.0.0/16 -j RETURN iptables -t mangle -A XRAY -d 172.16.0.0/12 -j RETURN iptables -t mangle -A XRAY -d 192.0.0.0/24 -j RETURN iptables -t mangle -A XRAY -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 240.0.0.0/4 -j RETURN iptables -t mangle -A XRAY -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN iptables -t mangle -A XRAY -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A PREROUTING -j XRAY iptables -t mangle -N XRAY_SELF iptables -t mangle -A XRAY_SELF -d 10.0.0.0/8 -j RETURN iptables -t mangle -A XRAY_SELF -d 100.64.0.0/10 -j RETURN iptables -t mangle -A XRAY_SELF -d 127.0.0.0/8 -j RETURN iptables -t mangle -A XRAY_SELF -d 169.254.0.0/16 -j RETURN iptables -t mangle -A XRAY_SELF -d 172.16.0.0/12 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.0.0.0/24 -j RETURN iptables -t mangle -A XRAY_SELF -d 224.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_SELF -d 240.0.0.0/4 -j RETURN iptables -t mangle -A XRAY_SELF -d 255.255.255.255/32 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p tcp ! --dport 53 -j RETURN iptables -t mangle -A XRAY_SELF -d 192.168.0.0/16 -p udp ! --dport 53 -j RETURN iptables -t mangle -A XRAY_SELF -m mark --mark 2 -j RETURN iptables -t mangle -A XRAY_SELF -p tcp -j MARK --set-mark 1 iptables -t mangle -A XRAY_SELF -p udp -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -j XRAY_SELF  After the configuration is complete, change the default gateway of other devices in the LAN to this device IP, and you can directly overturn the wall. After other hosts and this machine are tested successfully, you can proceed to the next configuration.\nConfigure Permanentization \u0026amp; Self-startup nftables First move the edited nftables configuration file to the /etc directory, and rename it to nftables.conf. And then edit /lib/systemd/system/nftables.service.\n[Unit] Description=nftables Documentation=man:nft(8) http://wiki.nftables.org Wants=network-pre.target Before=network-pre.target shutdown.target Conflicts=shutdown.target DefaultDependencies=no [Service] Type=oneshot RemainAfterExit=yes StandardInput=null ProtectSystem=full ProtectHome=true ExecStart=/usr/sbin/nft -f /etc/nftables.conf ; /usr/sbin/ip route add local default dev lo table 100 ; /usr/sbin/ip rule add fwmark 1 table 100 ExecReload=/usr/sbin/nft -f /etc/nftables.conf ExecStop=/usr/sbin/nft flush ruleset ; /usr/sbin/ip route del local default dev lo table 100 ; /usr/sbin/ip rule del table 100\n[Install] WantedBy=sysinit.target And finally enable will be done.\niptables Regarding the permanentization of iptables, it is recommended to install directly iptables-persistent.\nDuring the installation process, you will be prompted to choose \u0026ldquo;Whether to save the configuration\u0026rdquo;. If the iptables configuration has been written to the system, then select \u0026ldquo;Yes\u0026rdquo; at this time; if it has not been written, it doesn\u0026rsquo;t matter. After the installation is complete, write the configuration and execute netfilter-persistent save will be done (root permission is required).\nAnd then edit /lib/systemd/system/netfilter-persistent.service.\n[Unit] Description=netfilter persistent configuration DefaultDependencies=no Wants=network-pre.target systemd-modules-load.service local-fs.target Before=network-pre.target shutdown.target After=systemd-modules-load.service local-fs.target Conflicts=shutdown.target Documentation=man:netfilter-persistent(8) [Service] Type=oneshot RemainAfterExit=yes ExecStart=/usr/sbin/netfilter-persistent start ; /usr/sbin/ip route add local default dev lo table 100 ; /usr/sbin/ip rule add fwmark 1 table 100 ExecStop=/usr/sbin/netfilter-persistent stop ; /usr/sbin/ip route del local default dev lo table 100 ; /usr/sbin/ip rule del table 100 [Install] WantedBy=multi-user.target  "},{"uri":"https://xtls.github.io/en/develop/protocols/vmess/","title":"VMess 协议","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。\n\n版本  当前版本号为 1。\n\n依赖  底层协议  VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。\n\n用户 ID  ID 等价于 UUID，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如这个。\n用户 ID 可在配置文件中指定。\n\n函数   MD5: MD5 函数  输入参数为任意长度的 byte 数组 输出为一个 16 byte 的数组   HMAC: HMAC 函数  输入参数为：  H：散列函数 K：密钥，任意长度的 byte 数组 M：消息，任意长度的 byte 数组     Shake: SHA3-Shake128 函数  输入参数为任意长度的字符串 输出为任意长度的字符串    \n通讯过程  VMess 是一个无状态协议，即客户端和服务器之间不需要握手即可直接传输数据，每一次数据传输对之前和之后的其它数据传输没有影响。\nVMess 的客户端发起一次请求，服务器判断该请求是否来自一个合法的客户端。如验证通过，则转发该请求，并把获得的响应发回给客户端。\nVMess 使用非对称格式，即客户端发出的请求和服务器端的响应使用了不同的格式。\n\n客户端请求     16 字节 X 字节 余下部分     认证信息 指令部分 数据部分    \n认证信息  认证信息是一个 16 字节的哈希（hash）值，它的计算方式如下：\n H = MD5 K = 用户 ID (16 字节) M = UTC 时间，精确到秒，取值为当前时间的前后 30 秒随机值(8 字节, Big Endian) Hash = HMAC(H, K, M)  \n指令部分  指令部分经过 AES-128-CFB 加密：\n Key：MD5(用户 ID + []byte(\u0026lsquo;c48619fe-8f02-49e0-b9e9-edf763e17e21\u0026rsquo;)) IV：MD5(X + X + X + X)，X = []byte(认证信息生成的时间) (8 字节, Big Endian)     1 字节 16 字节 16 字节 1 字节 1 字节 4 位 4 位 1 字节 1 字节 2 字节 1 字节 N 字节 P 字节 4 字节     版本号 Ver 数据加密 IV 数据加密 Key 响应认证 V 选项 Opt 余量 P 加密方式 Sec 保留 指令 Cmd 端口 Port 地址类型 T 地址 A 随机值 校验 F    选项 Opt 细节：（当某一位为 1 时，表示该选项启用）\n   0 1 2 3 4 5 6 7     X X X X X M R S    其中：\n 版本号 Ver：始终为 1； 数据加密 IV：随机值； 数据加密 Key：随机值； 响应认证 V：随机值； 选项 Opt：  S (0x01)：标准格式的数据流（建议开启）； R (0x02)：客户端期待重用 TCP 连接（Xray 2.23+ 弃用）；  只有当 S 开启时，这一项才有效；   M (0x04)：开启元数据混淆（建议开启）；  只有当 S 开启时，这一项才有效； 当其项开启时，客户端和服务器端需要分别构造两个 Shake 实例，分别为 RequestMask = Shake(请求数据 IV), ResponseMask = Shake(响应数据 IV)。   X：保留   余量 P：在校验值之前加入 P 字节的随机值； 加密方式：指定数据部分的加密方式，可选的值有：  0x00：AES-128-CFB； 0x01：不加密； 0x02：AES-128-GCM； 0x03：ChaCha20-Poly1305；   指令 Cmd：  0x01：TCP 数据； 0x02：UDP 数据；   端口 Port：Big Endian 格式的整型端口号； 地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；   校验 F：指令部分除 F 外所有内容的 FNV1a hash；  \n数据部分  当 Opt(S) 开启时，数据部分使用此格式。实际的请求数据被分割为若干个小块，每个小块的格式如下。服务器校验完所有的小块之后，再按基本格式的方式进行转发。\n   2 字节 L 字节     长度 L 数据包    其中：\n 长度 L：Big Endian 格式的整型，最大值为 2^14；  当 Opt(M) 开启时，L 的值 = 真实值 xor Mask。Mask = (RequestMask.NextByte() \u0026laquo; 8) + RequestMask.NextByte()；   数据包：由指定的加密方式加密过的数据包；  在传输结束之前，数据包中必须有实际数据，即除了长度和认证数据之外的数据。当传输结束时，客户端必须发送一个空的数据包，即 L = 0（不加密） 或认证数据长度（有加密），来表示传输结束。\n按加密方式不同，数据包的格式如下：\n 不加密：  L 字节：实际数据；   AES-128-CFB：整个数据部分使用 AES-128-CFB 加密  4 字节：实际数据的 FNV1a hash； L - 4 字节：实际数据；   AES-128-GCM：Key 为指令部分的 Key，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：GCM 认证信息   ChaCha20-Poly1305：Key = MD5(指令部分 Key) + MD5(MD5(指令部分 Key))，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。  L - 16 字节：实际数据； 16 字节：Poly1305 认证信息    \n服务器应答  应答头部数据使用 AES-128-CFB 加密，IV 为 MD5(数据加密 IV)，Key 为 MD5(数据加密 Key)。实际应答数据视加密设置不同而不同。\n   1 字节 1 字节 1 字节 1 字节 M 字节 余下部分     响应认证 V 选项 Opt 指令 Cmd 指令长度 M 指令内容 实际应答数据    其中：\n 响应认证 V：必须和客户端请求中的响应认证 V 一致； 选项 Opt：  0x01：服务器端准备重用 TCP 连接（Xray 2.23+ 弃用）；   指令 Cmd：  0x01：动态端口指令   实际应答数据：  如果请求中的 Opt(S) 开启，则使用标准格式，否则使用基本格式。 格式均和请求数据相同。  当 Opt(M) 开启时，长度 L 的值 = 真实值 xor Mask。Mask = (ResponseMask.NextByte() \u0026laquo; 8) + ResponseMask.NextByte()；      \n动态端口指令     1 字节 2 字节 16 字节 2 字节 1 字节 1 字节     保留 端口 Port 用户 ID AlterID 用户等级 有效时间 T    其中：\n 端口 Port：Big Endian 格式的整型端口号； 有效时间 T：分钟数；  客户端在收到动态端口指令时，服务器已开放新的端口用于通信，这时客户端可以将数据发往新的端口。在 T 分钟之后，这个端口将失效，客户端必须重新使用主端口进行通信。\n\n注释   为确保向前兼容性，所有保留字段的值必须为 0。  "},{"uri":"https://xtls.github.io/en/config/transports/websocket/","title":"WebSocket","tags":[],"description":"Project X 的文档.","content":"使用标准的 WebSocket 来传输数据。\nWebSocket 连接可以被其它 HTTP 服务器（如 Nginx）分流，也可以被 VLESS fallbacks path 分流。\nTIP\nWebsocket 会识别 HTTP 请求的 X-Forwarded-For 头来覆写流量的源地址，优先级高于 PROXY protocol。\n WebSocketObject WebSocketObject 对应传输配置的 wsSettings 项。\n{ \u0026#34;acceptProxyProtocol\u0026#34;: false, \u0026#34;path\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;Host\u0026#34;: \u0026#34;xray.com\u0026#34; } }  acceptProxyProtocol: true | false\n 仅用于 inbound，指示是否接收 PROXY protocol。\nPROXY protocol 专用于传递请求的真实来源 IP 和端口，若你不了解它，请先忽略该项。\n常见的反代软件（如 HAProxy、Nginx）都可以配置发送它，VLESS fallbacks xver 也可以发送它。\n填写 true 时，最底层 TCP 连接建立后，请求方必须先发送 PROXY protocol v1 或 v2，否则连接会被关闭。\npath string\n WebSocket 所使用的 HTTP 协议路径，默认值为 \u0026quot;/\u0026quot;。\nheaders: map {string: string}\n 自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。\n默认值为空。\n"},{"uri":"https://xtls.github.io/en/develop/protocols/","title":"协议详解","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了 Xray 中所使用协议的详细剖析 \n vless\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 Mux.Cool\n Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。 mKCP\n mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n"},{"uri":"https://xtls.github.io/en/develop/intro/design/","title":"设计思路","tags":[],"description":"Project X 的文档.","content":"设计目标   Xray 内核提供了一个平台，支持必要的网络代理功能，在其之上可以进二次开发，以提供更好的用户体验； 以跨平台为首要原则，以减少二次开发的成本；  \n架构  内核分为三层：应用层、代理层和传输层。\n每一层内包含数个模块，模块间互相独立，同类型的模块可无缝替换。\n\n应用层  应用层包含一些代理层中常用的功能，这些功能被抽象出来，以便在不同的代理模块中复用。\n应用层的模块应为纯软件实现，与硬件或平台相关的技术无关。\n重要模块列表：\n Dispatcher: 用于把入站代理所接收到的数据，传送给出站代理； Router: 路由模块，详见 路由配置； DNS: 内置的 DNS 服务器模块； Proxy Manager: 代理管理器；  \n代理层  代理层分为两部分：入站代理（Inbound Proxy）和出站代理（Outbound Proxy）。\n两部分相互独立，入站代理不依赖于某个特定的出站代理，反之亦然。\n入站代理   实现 proxy.Inbound 接口；  出站代理   实现 proxy.Outbound 接口；  \n传输层  传输层提供一些网络数据传输相关的工具模块。\n"},{"uri":"https://xtls.github.io/en/faq/config/","title":"配置和运行时的问题","tags":[],"description":"Project X 的文档.","content":" Q: 为什么windows下只有一个可执行程序? 我想要隐藏执行, 嘤嘤嘤.A1: 方式很多,如: 建立一个hiderun.vbs文件,放在xray.exe同一目录 编辑内容为\nCreateObject(\u0026#34;WScript.Shell\u0026#34;).Run \u0026#34;xray.exe\u0026#34;,0 运行此vbs即可, 然后放个快捷方式到shell:startup里面，就可以开机启动了\n A2: 也可以通过创建window服务/计划任务等方式实现,亦可借助一些专门的后台运行的工具(不太必要)\n A3: CHP (Create Hidden Process)\n A4: 用winsw可以将xray-core添加为Win的系统服务，开机自动运行，不需要手动隐藏窗口。\n A5: 写一个bat开机启动\n@echo off if \u0026#34;%1\u0026#34; == \u0026#34;h\u0026#34; goto begin mshta vbscript:createobject(\u0026#34;wscript.shell\u0026#34;).run(\u0026#34;%~nx0 h\u0026#34;,0)(window.close)\u0026amp;\u0026amp;exit :begin D:/Xray run -c D:/Xray.json ` \n \nQ: 无法用做Tor前置代理 #66关闭 sniffing 再试试.\n \nQ: 如何自定义.dat文件的文件位置?设置环境变量 XRAY_LOCATION_ASSET 的值\n \nQ: 为什么我配置了SSL证书但不可用? 检查证书权限 使用 fullchain 证书   \nQ: 我以前用gfw列表, 我现在用Xray怎么进行分流呢?使用geo*.dat, 并且合理配置路由规则.\n \nQ: 我还是上一题的提问者, 那么我如何使用dat数据文件和配置路由规则达到国内走直连,其他走代理的目的呢?等待好心人写一篇小小白白话文\n \nQ: 如何配置才能在myssl或者ssllibs得到双A+的评价？首先，这不是必需的，即便没有双A+，甚至只有B，也并不意味着不安全。\n你现在可以这样做:\n 前提, 你的证书是ECC证书, 比如你用acme.sh可以这样获取  ./acme.sh --issue -d \u0026#34;your.domain\u0026#34; -w /var/www/html -k ec-256 --cert-file /etc/xray/\u0026#34;your.domain\u0026#34;/\u0026#34;your.domain\u0026#34;.cer --key-file /etc/xray/\u0026#34;your.domain\u0026#34;/\u0026#34;your.domain\u0026#34;.key --fullchain-file /etc/xray/\u0026#34;your.domain\u0026#34;/fullchain.cer --force \n只需简单的在 服务端的 TLS 配置 (streamsettings中的tlsSettings/xtlsSettings) 中加入  \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34; 即可在myssl或ssllabs上获得A\n\n然后在回落的网站服务器上开启HSTS,如 Nginx 只需配置  add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; 即可在myssl或ssllabs上获得A+\n \nQ: 什么是UDP fullcone?fullcone的核心改变在于对游戏性能、使用到UDP的语音视频性能的优化。\n很多游戏会测试网络类型，类型过低甚至不能联机。fullcone一般都可以达到最佳类型。\n \n"},{"uri":"https://xtls.github.io/en/guide/config/","title":"Configure and run","tags":[],"description":"Project X Documents","content":"Once you downloaded and installed xray, you will need to configure it.\nFor demonstration purposes, only simple configurations are described here.\nFor more complex configurations, please refer to the more detailed configuration file for more detailed instructions.\n\nServer-side configuration  You will need a server outside the firewall to run the server-side xray. Configure it as follows.\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 10086, // Port that the server listens on \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; } ] } The server needs to be configured to ensure that the id and the port are the same as the client\u0026rsquo;s and you will be able to connect properly.\n\nClient-side configuration  On your PC (or mobile phone), you need to run xray with the following configuration.\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 1080, // SOCKS proxy port, you need to configure the proxy in your browser and point to this port \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } } ], \u0026#34;outbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;server\u0026#34;, // Server address, please change to your own server ip or domain name \u0026#34;port\u0026#34;: 10086, // Server port \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;b831381d-6324-4d53-ad4f-8cda48b30811\u0026#34; } ] } ] } }, { \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34; } ], \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;IPOnDemand\u0026#34;, \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [\u0026#34;geoip:private\u0026#34;], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; } ] } } You only need to change the server IP, which is indicated in the configuration. The above configuration will forward all traffic to your server except for the LAN (e.g. access to the router).\n\nRun   On Windows and macOS, the configuration file is usually a config.json file in the same directory as xray.  Just run xray or xray.exe directly.   On Linux, the configuration file is usually located in the /etc/xray/ or /usr/local/etc/xray/ directory.  Run xray run -c /etc/xray/config.json or use a tool such as systemd to run xray as a service in the background.    More detailed instructions can be found in the configuration documents and usage tips.\n"},{"uri":"https://xtls.github.io/en/guide/","title":"Quick start","tags":[],"description":"Project X Documents","content":" This section will show you how to get xray in the easiest way and start using it. Download and install Xray supports a wide range of platforms and is available in various versions from a variety of sources and methods.\nPlease click How to download and install xray to get xray.\n Configure and run Once you have downloaded and installed xray, simply configure it to work.\nPlease click on How to configure and run xray to learn the easiest way to configure it.\n Command parameters Xray has a wide range of commands and parameters available, making it flexible and powerful.\nPlease click on xray\u0026rsquo;s command parameters to see more command and parameter usage for xray.\n  \nUsage documents You are looking at the project X documentation site. You can find out more about how to use the site, or help us improve the quality of our documentation.\nPlease click on usage documents to see further content.\n    "},{"uri":"https://xtls.github.io/en/config/","title":"Configuration files","tags":[],"description":"Project X Documents","content":" This section will give you all the details of xray configuration. Mastered this, xray will be even more powerful in your hands. Summary  The xray configuration file is in json format, there is no difference between the client and server configuration formats, only the actual content of the configuration is different. As follows:\n{ \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [], \u0026#34;outbounds\u0026#34;: [], \u0026#34;transport\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;reverse\u0026#34;: {} }  TIP\nIf you are new to xray, you can learn the basics first by clicking onDownload and install, then read this section for all the ways to configure xray.\n "},{"uri":"https://xtls.github.io/en/documents/level-0/ch03-ssh/","title":"【第3章】远程登录篇","tags":[],"description":"小小白白话文","content":"3.1 远程登录VPS (PuTTY)  首先，鉴于零基础人群中Windows的用户基数最大，所以本文以Windows为例进行展示。\n其次，虽然Windows 10之后的PowerShell和WSL也可以达到很好的SSH操作体验。但是因为并非所有版本的Windows都有最新的组件，故本文还是以老牌的PuTTY为例，进行SSH远程登录的操作详解。（使用其他工具的话、在SSH登陆之后的操作都是一样的）\n下面就跟我一步步操作吧。\n  进入PuTTY的官网，选择适合你操作系统的版本下载。（本文以64位版本为例）\n  安装运行后，将会看到PuTTY的主界面。现在请拿出你上一章记东西的小本本，在下图的对应位置填入你VPS的IP地址(VPS IP)和端口(VPS PORT)。为了方便以后使用时不用重复输入，我们可以保存会话 (Saved Sessions)，未来使用时只要按Load即可一键载入设置。\n  我建议将 Connection 中的 keepalive 设置为 60 秒，防止你一段时间没有操作之后SSH自动断线。另外务必再次保存设置。\n注意： 对PuTTY的任何设置更新都要再次手动保存Session，不然关闭后就会丢失\n   点击 Open 就会进入SSH连接窗口，对应下图输入用户名与密码，与你的VPS远程主机建立连接。（本文假设默认用户名是 root，另外，在Linux系统输入密码的时候，是不会出现 ****** 这种提示符的，这样可以避免密码长度泄漏，不是你的键盘坏掉了哦！）\n   3.2 成功登录SSH！初识命令行界面！    如果你的信息都填写正确，你将会看到类似下图的界面，说明已登录成功：\n这个界面，就等于远程服务器的【桌面】，但它没有你熟悉的图标和鼠标，没有绚丽的色彩，有的只是简单文字，这就是【命令行界面】- Command Line Interface，或者缩写为 CLI。\n接下来的所有操作，都需要你像电影里的黑客一样，在这个命令行界面中完成。也许你会觉得陌生，但请相信我，使用命令行既不可怕，也不神秘。说到底，它只不过是把你习惯的鼠标操作变成了文字指令而已，你说一句，它做一句。\n  现在，你可以稍微观察并熟悉一下命令行环境，这个界面其实已经告诉了你一些有用的信息了，比如系统内核版本（比如图内是 4.19.37-5）、上次登录时间及IP等。当然根据VPS的不同，你看到的界面可能会略有不同。\n  请注意命令行最下面一行，闪动的光标左边，有一串字符。图中显示的是root@vps-server:~#，这一串要怎么理解呢？很简单：\n 现在的用户是 root root 所在的服务器是 vps-server root 现在所在的文件夹是 ~ # 之后是你可以输入命令的地方  前两个很直观，无需多说。第三个是关于Linux的文件夹系统，现在也不需要过于深入，你只需要知道，\u0026quot;~\u0026ldquo;就是【当前用户的大本营】。第四个，提示符#，你也不用管，只需要知道，未来文章中会写一些需要你输入的命令，都会以 \u0026ldquo;#\u0026rdquo; 或者 \u0026ldquo;$\u0026rdquo; 开头，提示你后面是你输入命令的地方。（所以你复制命令的时候，只需要复制后面的内容，不要复制提示符）\n   3.3 第一次更新Linux的软件！    正如你的手机，无论安卓还是iPhone，为了APP及时更新（获取安全补丁和新功能），都会时不时从应用商店获得更新信息，并且提示你有多少个APP可更新。Linux系统也有逻辑十分类似的更新机制。所以只要你会更新手机APP，就能学会更新Linux软件！\n  Linux下，每个APP都叫做一个“包” （package）。管理APP的程序自然就叫做“包管理器”（Package Manager）。你可以通过它安装、更新、卸载各种软件、甚至更新Linux系统本身。Linux下的包管理器非常强大，此处按下不表，现在你只需要知道Debian系统的包管理器叫做 apt 即可。接下来，我们就先使用 apt 做一次软件的全面更新，让你熟悉它的基本操作。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-01 apt update 查询软件更新   cmd-02 apt upgrade 执行软件更新      现在请输入第一条命令，获取更新信息\n# apt update   然后请输入第二条命令，并在询问是否继续安装 (Y/n) 时输入 y 并回车确认，开始安装\n# apt upgrade   完整流程演示如下：\n   3.4 你的进度  恭喜你又迈出了坚实的一步！ 现在，你已经可以通过SSH来登录你的远程服务器了！那登录进去之后，除了升级软件之外，应该再做点什么呢？敬请进入下一章一探究竟吧！\nPROGRESS⬛⬛⬛⬜⬜⬜⬜⬜ 37.5%\n "},{"uri":"https://xtls.github.io/en/config/transports/domainsocket/","title":"Domain Socket","tags":[],"description":"Project X 的文档.","content":" important推荐写到 inbounds 的 listen 处，传输方式可选 TCP、WebSocket、HTTP/2.\n未来这里的 DomainSocket 可能会被弃用。\n Domain Socket 使用标准的 Unix domain socket 来传输数据。\n它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。 理论上相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。\n目前仅可用于支持 Unix domain socket 的平台，如 Linux 和 macOS。在 Windows 10 Build 17036 前不可用。\n如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。\nDomainSocketObject  DomainSocketObject 对应传输配置的 dsSettings 项。\n{ \u0026#34;path\u0026#34;: \u0026#34;/path/to/ds/file\u0026#34;, \u0026#34;abstract\u0026#34;: false, \u0026#34;padding\u0026#34;: false }  path: string\n 一个合法的文件路径。 important在运行 Xray 之前，这个文件必须不存在。\n abstract: true | false\n 是否为 abstract domain socket，默认值 false。\n padding: true | false\n abstract domain socket 是否带 padding，默认值 false。\n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/freedom/","title":"Freedom","tags":[],"description":"Project X 的文档.","content":"Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。\nOutboundConfigurationObject  { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:3366\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;UseIP\u0026rdquo; | \u0026ldquo;UseIPv4\u0026rdquo; | \u0026ldquo;UseIPv6\u0026rdquo;\n 在目标地址为域名时, 配置相应的值, Freedom 的行为模式如下:\n \u0026quot;AsIs\u0026quot;: Freedom 通过系统DNS服务器解析获取IP, 向此域名发出连接. \u0026quot;UseIP\u0026quot;、\u0026quot;UseIPv4\u0026quot; 和 \u0026quot;UseIPv6\u0026quot;: Xray 使用内置 DNS 服务器解析获取IP, 向此域名发出连接. 默认值为 \u0026quot;AsIs\u0026quot;。   TIP 1\n当使用 \u0026quot;UseIP\u0026quot; 模式，并且出站连接配置 中指定了 sendThrough 时，Freedom 会根据 sendThrough 的值自动判断所需的 IP 类型，IPv4 或 IPv6。\n TIP 2\n当使用 \u0026quot;UseIPv4\u0026quot; 或 \u0026quot;UseIPv6\u0026quot; 模式时，Freedom 会只使用对应的 IPv4 或 IPv6 地址。当 sendThrough 指定了不匹配的本地地址时，将导致连接失败。\n redirect: address_port\n Freedom 会强制将所有数据发送到指定地址（而不是 inbound 指定的地址）。\n其值为一个字符串，样例：\u0026quot;127.0.0.1:80\u0026quot;，\u0026quot;:1234\u0026quot;。\n当地址不指定时，如 \u0026quot;:443\u0026quot;，Freedom 不会修改原先的目标地址。 当端口为 0 时，如 \u0026quot;xray.com: 0\u0026quot;，Freedom 不会修改原先的端口。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/en/config/inbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP 1\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n TIP 2\n在 Linux 中使用以下环境变量即可在当前 session 使用全局 HTTP 代理（很多软件都支持这一设置，也有不支持的）。\n export http_proxy=http://127.0.0.1:8080/ (地址须改成你配置的 HTTP 入站代理地址) export https_proxy=$http_proxy   InboundConfigurationObject  { \u0026#34;timeout\u0026#34;: 0, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;allowTransparent\u0026#34;: false, \u0026#34;userLevel\u0026#34;: 0 }  timeout: number\n 连接空闲的时间限制。单位为秒。默认值为 300, 0 表示不限时。\n处理一个连接时，如果在 timeout 时间内，没有任何数据被传输，则中断该连接。\naccounts: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n当 accounts 非空时，HTTP 代理将对入站连接进行 Basic Authentication 验证。\nallowTransparent: true | false\n 当为 true 时，会转发所有 HTTP 请求，而非只是代理请求。\nTIP\n若配置不当，开启此选项会导致死循环。\n userLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/en/develop/protocols/muxcool/","title":"Mux.Cool 协议","tags":[],"description":"Project X 的文档.","content":"Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。\n\n版本  当前版本是 1 Beta。\n\n依赖  底层协议  Mux.Cool 必须运行在一个已建立的可靠数据流之上。\n\n通讯过程  一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。\n\n客户端行为  当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。\n 一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。 对于一个新的子连接，客户端必须发送状态New以通知服务器建立子连接，然后使用状态Keep来传送数据。 当子连接结束时，客户端发送End状态来通知服务器关闭子连接。 客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。 客户端可使用 KeepAlive 状态来避免服务器关闭主连接。  \n服务器端行为  当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。\n 当收到状态End时，服务器端可以关闭对目标地址的上行连接。 在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。 服务器不能使用New状态。 服务器可使用 KeepAlive 状态来避免客户端关闭主连接。  \n传输格式  Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。\n\n帧格式     2 字节 L 字节 X 字节     元数据长度 L 元数据 额外数据    \n元数据  元数据有若干种类型，由状态 S 来区分。所有类型的元数据都包含 ID 和 Opt 两项，其含义为：\n ID: 子连接的唯一标识 Opt:  D(0x01): 有额外数据    当选项 Opt(D) 开启时，额外数据格式如下：\n   2 字节 L 字节     长度 L 数据    \n新建子连接 (New)     2 字节 1 字节 1 字节 1 字节 2 字节 1 字节 X 字节     ID 0x01 选项 Opt 网络类型 N 端口 地址类型 T 地址 A    其中：\n 网络类型 N：  0x01：TCP，表示当前子连接的流量应当以 TCP 的方式发送至目标。 0x02：UDP，表示当前子连接的流量应当以 UDP 的方式发送至目标。   地址类型 T：  0x01：IPv4 0x02：域名 0x03：IPv6   地址 A：  当 T = 0x01 时，A 为 4 字节 IPv4 地址； 当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名； 当 T = 0x03 时，A 为 16 字节 IPv6 地址；    在新建子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持子连接 (Keep)     2 字节 1 字节 1 字节     ID 0x02 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n关闭子连接 (End)     2 字节 1 字节 1 字节     ID 0x03 选项 Opt    在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。\n\n保持连接 (KeepAlive)     2 字节 1 字节 1 字节     ID 0x04 选项 Opt    在保持连接时:\n 若 Opt(D) 开启，则这一帧所带的数据必须被丢弃。 ID 可为随机值。  \n应用  Mux.Cool 协议与底层协议无关，理论上可以使用任何可靠的流式连接来传输 Mux.Cool 的协议数据。\n在目标导向的协议如 Shadowsocks 和 VMess 协议中，连接建立时必须包含一个指定的地址。\n为了保持兼容性，Mux.Cool 协议指定地址为“v1.mux.cool”。即当主连接的目标地址与之匹配时，则进行 Mux.Cool 方式的转发，否则按传统方式进行转发。\n"},{"uri":"https://xtls.github.io/en/documents/level-2/iptables_gid/","title":"Transparent proxy to circumvent Xray traffic via gid","tags":[],"description":"Project X Documentation.","content":"In the existing transparent proxy configuration(New V2Ray vernacular tutorial on transparent proxy 、 New V2Ray vernacular tutorial on transparent proxy (TProxy) 、 Transparent proxy（TProxy）configuration tutorial)tutorials, the circumvention of Xray traffic is achieved by using mark. That is, mark the Xray outbound traffic and circumvent the Xray traffic by setting up iptables rules for direct connection of the traffic corresponding to the mark to prevent loopback.\nThere are several problems with this method:\n  Inexplicable traffic into PREROUTING chain\n  Android has its own mark mechanism and this solution is not available on Android\n  The solution in this tutorial does not require a mark setting and has a higher theoretical performance, as well as not having the problems mentioned above.\nIdeas TProxy traffic can only be received by users with root privileges (uid==0) or other users with CAP_NET_ADMIN privileges.\nThe iptables rules can separate network traffic by uid (user id) and gid (user group id). Let Xray run on a user with uid==0 but gid!=0. Set the iptables rule to not proxy traffic for that gid to circumvent Xray traffic.\nConfiguration Procedure 1. Preliminary preparation Android\n  System has root privilege.\n  Install busybox\n  There is a terminal that can execute commands, you can use adb shell, termux etc.\n  Other Linux system\nNeed sudo, iptables-tproxy module and iptables-extra module。\nUsually the system comes with these functions. If you are using openwrt, you will need to run the following command:\nopkg install sudo iptables-mod-tproxy iptables-mod-extra Also attached are some common dependencies for openwrt, the lack of which may prevent Xray from running\nopkg install libopenssl ca-certificates 2. Add user (Android users please ignore this section) Android does not support managing users by modifying the /etc/passwd file, please ignore it and go straight to the next step.\ngrep -qw xray_tproxy /etc/passwd || echo \u0026#34;xray_tproxy:x:0:23333:::\u0026#34; \u0026gt;\u0026gt; /etc/passwd where xray_tproxy is the username, 0 is the uid and 23333 is the gid, the username and gid can be set by yourself, the uid must be 0. To check if the user was added successfully, run\nsudo -u xray_tproxy id The result displayed should be uid 0 and gid 23333.\n3. Configure and run Xray, and configure iptables rules In the existing transparent proxy configuration(New V2Ray vernacular tutorial on transparent proxy 、 New V2Ray vernacular tutorial on transparent proxy (TProxy) 、 Transparent proxy（TProxy）configuration tutorial)tutorials, modify:\n  Modify the json configuration file: remove mark-related content\n  Modify the iptables rule to remove the mark-related content and add the option at the OUTPUT chain application rule: \u0026ldquo;-m owner ! \u0026ndash;gid-owner 23333\u0026rdquo;\n  e.g.:\niptables -t mangle -A OUTPUT -j XRAY_SELF\nChange to\niptables -t mangle -A OUTPUT -m owner ! --gid-owner 23333 -j XRAY_SELF\n Modify the way you run Xray so that it runs on a user with uid 0 and gid 23333, refer to here.  The following provides a complete configuration process for implementing the tproxy global proxy 1. Finish Preliminary preparation 和 Add user 2. Preparing Xray profiles Configure Xray to listen to 12345 at dokodemo-door, turn on followRedirect and tproxy, no sniffing required:\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 12345, \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp,udp\u0026#34;, \u0026#34;followRedirect\u0026#34;: true }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;sockopt\u0026#34;: { \u0026#34;tproxy\u0026#34;: \u0026#34;tproxy\u0026#34; } } } ], \u0026#34;outbounds\u0026#34;: [ { # Your server configuration } ] } 3. Configuring the maximum number of open files and run the Xray client About the maximum number of open files, see: too many open files issues\nThe current Xray server installed with the official script has the maximum number of open files automatically configured, so no further changes are required.\nAndroid\nulimit -SHn 1000000 setuidgid 0:23333 \u0026#34;Command to run Xray\u0026#34;\u0026amp; Other Linux system\nulimit -SHn 1000000 sudo -u xray_tproxy \u0026#34;Command to run Xray\u0026#34;\u0026amp; e.g.:\nulimit -SHn 1000000 sudo -u xray_tproxy xray -c /etc/xray/config.json \u0026amp; The first command:\nChange the maximum number of open files, valid only for the current terminal and to be run every time before starting Xray, this command is to set the maximum number of open files for the client.\nThe second command:\nRun the Xray client as a user with uid 0 and gid not 0, followed by \u0026amp; for running in the background.\nCheck that the maximum number of open files is set successfully\ncat /proc/\u0026#34;Xray\u0026#39;s pid\u0026#34;/limits Find max open files, which should be the value you set. Xray\u0026rsquo;s pid can be obtained by running ps or ps -aux or ps -a\nBoth the server and client side should be checked.\n4. Setting up iptables rules Proxy ipv4\nip rule add fwmark 1 table 100 ip route add local 0.0.0.0/0 dev lo table 100 # Proxy LAN devices iptables -t mangle -N XRAY # \u0026#34;ipv4 segment where the gateway is located\u0026#34; is obtained by running the command \u0026#34;ip address | grep -w inet | awk \u0026#39;{print $2}\u0026#39;\u0026#34;, usually there are multiple iptables -t mangle -A XRAY -d \u0026#34;first ipv4 segment where the gateway is located\u0026#34; -j RETURN iptables -t mangle -A XRAY -d \u0026#34;second ipv4 segment where the gateway is located\u0026#34; -j RETURN # If the gateway is used as the primary router, add this line, see: [Other considerations for transparent proxy of iptables](https://xtls.github.io/en/documents/level-2/transparent_proxy/transparent_proxy/#proxy-ipv6) # The \u0026#34;gateway LAN_IPv4 address segment\u0026#34;, obtained by running the command \u0026#34;ip address | grep -w \u0026#34;inet\u0026#34; | awk \u0026#39;{print $2}\u0026#39;\u0026#34;, is one of the results iptables -t mangle -A XRAY ! -s \u0026#34;gateway LAN_IPv4 address segment\u0026#34; -j RETURN # Mark 1 for TCP and forward to port 12345 # mark can only be set to 1 for the traffic to be accepted by the Xray dokodemo-door iptables -t mangle -A XRAY -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 iptables -t mangle -A XRAY -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 # Apply rules iptables -t mangle -A PREROUTING -j XRAY # Proxy gateway itself iptables -t mangle -N XRAY_MASK iptables -t mangle -A XRAY_MASK -d \u0026#34;the first ipv4 segment where the gateway is located\u0026#34; -j RETURN iptables -t mangle -A XRAY_MASK -d \u0026#34;the second ipv4 segment where the gateway is located\u0026#34; -j RETURN iptables -t mangle -A XRAY_MASK -j MARK --set-mark 1 iptables -t mangle -A OUTPUT -m owner ! --gid-owner 23333 ! -p icmp -j XRAY_MASK Proxy ipv6 (optional)\nip -6 rule add fwmark 1 table 106 ip -6 route add local ::/0 dev lo table 106 # Proxy LAN devices ip6tables -t mangle -N XRAY6 # The \u0026#34;ipv6 segment where the gateway is located\u0026#34; is obtained by running the command \u0026#34;ip address | grep -w inet6 | awk \u0026#39;{print $2}\u0026#39;\u0026#34;. ip6tables -t mangle -A XRAY6 -d \u0026#34;the first ipv6 segment where the gateway is located\u0026#34; -j RETURN ip6tables -t mangle -A XRAY6 -d \u0026#34;the second ipv6 segment where the gateway is located\u0026#34; -j RETURN # If the gateway is used as the primary router, add this line, see: [Other considerations for transparent proxy of iptables](https://xtls.github.io/en/documents/level-2/transparent_proxy/transparent_proxy/#proxy-ipv6) # The \u0026#34;gateway LAN_IPv6 address segment\u0026#34;, obtained by running the command \u0026#34;ip address | grep -w \u0026#34;inet6\u0026#34; | awk \u0026#39;{print $2}\u0026#39;\u0026#34;, is one of the results ip6tables -t mangle -A XRAY6 ! -s \u0026#34;gateway LAN_IPv6 address segment\u0026#34; -j RETURN ip6tables -t mangle -A XRAY6 -p udp -j TPROXY --on-port 12345 --tproxy-mark 1 ip6tables -t mangle -A XRAY6 -p tcp -j TPROXY --on-port 12345 --tproxy-mark 1 ip6tables -t mangle -A PREROUTING -j XRAY6 # Proxy gateway itself ip6tables -t mangle -N XRAY6_MASK ip6tables -t mangle -A XRAY6_MASK -d \u0026#34;the first ipv6 segment where the gateway is located\u0026#34; -j RETURN ip6tables -t mangle -A XRAY6_MASK -d \u0026#34;the second ipv6 segment where the gateway is located\u0026#34; -j RETURN ip6tables -t mangle -A XRAY6_MASK -j MARK --set-mark 1 ip6tables -t mangle -A OUTPUT -m owner ! --gid-owner 23333 ! -p icmp -j XRAY6_MASK "},{"uri":"https://xtls.github.io/en/develop/intro/guide/","title":"开发规范","tags":[],"description":"Project X 的文档.","content":"基本  版本控制  project X 的代码被托管在github上:\n xray 核心 xray-core xray-flutter xray-flutter 安装脚本 Xray-install 数据文件 Xray-rules-dat 配置模板 Xray-examples xray文档 XTLS.github.io  您可以使用 Git 来获取代码.\n 分支（Branch）  本项目的主干分支为 main, main 分支也是发布时所使用的代码分支, 因此需要确保 master 在任一时刻都是可编译可使用的。\n如果需要开发新的功能\n 请新开分支进行开发, 在开发完成并且经过充分测试后, 合并回主干分支. 新开分支如没有必要再存在时, 可以去除.   发布（Release）  In progress\n 建立尝鲜版本和稳定版本两个发布通道  临时版本, 主要用于特定情况的测试(比如从分支build的), 于TG群内/issue回复等渠道 发布特定版本 尝鲜版本可以为daily build , 用于尝鲜和获得即时反馈和再改进. 稳定版本为定时更新(比如周更), 合并稳定的修改并发布.     引用其它项目   Golang  产品代码建议使用 Golang 标准库和 golang.org/x/ 下的库； 如需引用其它项目，请事先创建 issue 讨论；   其它  不违反双方的协议，且对项目有帮助的工具，都可以使用。     开发流程  写代码之前  发现任何问题，或对项目有任何想法，请创建 Issue 讨论以减少重复劳动和消耗在代码上的时间。\n 修改代码   Golang  请参考 Effective Go； 每一次 push 之前，请运行：go fmt ./... 和 go fmt -s -l -e -w $(find . -type f -name \u0026quot;*.go\u0026quot; ! -name \u0026quot;*.pb.go\u0026quot;)； 每一次 push 之前，请确保测试通过：go test ./...； 提交 pull request 之前，请确保新增代码有超过 70% 的代码覆盖率（code coverage）；   其它  请注意代码的可读性。     Pull Request   提交 PR 之前，请先运行 git pull https://github.com/xray/xray-core.git 以确保 merge 可顺利进行； 一个 PR 只做一件事，如有对多个 bug 的修复，请对每一个 bug 提交一个 PR； 由于 Golang 的特殊需求（Package path），Go 项目的 PR 流程和其它项目有所不同 ,建议流程如下：  先 Fork 本项目，创建自己的 github.com/your/Xray-core 仓库； 克隆自己的 Xray 仓库到本地：git clone https://github.com/your/Xray-core.git； 基于 main 分支创建新的分支； 在自行创建的分支上作修改并提交修改(commit)； 在推送(push)修改完成的分支到自己的仓库前，先切换到 main 分支，运行 git pull https://github.com/v2fly/Xray-core.git 拉取最新的远端代码； 如果上一步拉取得到了新的远端代码，则切换到之前自己创建的分支，运行 git rebase master 执行分支合并操作。如遇到文件冲突，则需要解决冲突； 上一步处理完毕后，就可以把自己创建的分支推送到自己的仓库：git push -u origin your-branch 最后，把自己仓库的新推送的分支往 xtls/Xray-core 的 main 分支发 PR 即可； 请在 PR 的标题和正文中，完整表述此次 PR 解决的问题 / 新增的功能 / 代码所做的修改的用意等； 耐心等待开发者的回应。    对代码的修改  功能性问题  请提交至少一个测试用例（Test Case）来验证对现有功能的改动。\n性能相关  请提交必要的测试数据来证明现有代码的性能缺陷，或是新增代码的性能提升。\n新功能   如果新增功能对已有功能不影响，请提供可以开启/关闭的开关（如 flag），并使新功能保持默认关闭的状态； 大型新功能（比如增加一个新的协议）开发之前，请先提交一个 issue，讨论完毕之后再进行开发。  其它  视具体情况而定。\n Xray 编码规范  以下内容适用于 Xray 中的 Golang 代码。\n代码结构  Xray-core ├── app // 应用模块 │ ├── router // 路由 ├── common // 公用代码 ├── proxy // 通讯协议 │ ├── blackhole │ ├── dokodemo-door │ ├── freedom │ ├── socks │ ├── vmess ├── transport // 传输模块 编码规范  基本与 Golang 官方所推荐做法一致，有一些例外。写在这里以方便大家熟悉 Golang。\n命名   文件和目录名尽量使用单个英文单词，比如 hello.go；  如果实在没办法，则目录使用连接线／文件名使用下划线连接两个（或多个单词），比如 hello-world/hello_again.go； 测试代码使用 _test.go 结尾；   类型使用 Pascal 命名法，比如 ConnectionHandler；  对缩写不强制小写，即 HTML 不必写成 Html；   公开成员变量也使用 Pascal 命名法； 私有成员变量使用 小驼峰式命名法 ，如 privateAttribute ； 为了方便重构，方法建议全部使用 Pascal 命名法；  完全私有的类型放入 internal 。     内容组织   一个文件包含一个主要类型，及其相关的私有函数等； 测试相关的文件，如 Mock 等工具类，放入 testing 子目录。  "},{"uri":"https://xtls.github.io/en/faq/performance/","title":"性能相关的问题","tags":[],"description":"Project X 的文档.","content":" Q: 我是瓜瓜, 我想问 Xray 是不是最快的?是.\n Q: 什么工具或协议组合最快啊?/我应该用什么工具协议组合啊?个人自建上网,首先考虑安全性和伪装性,然后选择能满足自己需求的最高性能组合\n上网速率的高低, 体感的快慢, 根本的决定因素是线路 因此所有的选择跟你的实际环境息息相关,有时候需要一些特殊手段处理, 比如\n 比如低质量的线路可用使用CF加速. 比如晚上高峰期严重丢包的情况下, 可用使用mkcp(上限很低), 让线路尽量跑的更流畅一些.  在通常的环境下, 各种工具/协议组合的性能的高低, 可以参考Xray性能对比测试\n Q: mac和win 使用splice是不是无解了？ Windows 提供了 TransmitFile，但似乎不能用于两个 TCP 对接 Windows 10 有 WSL  WSL 1 使用 Splice 性能捉急. 不清楚 WSL 2 会不会带来额外拷贝开销，需要更多勇士尝试并反馈.   macOS暂无计划   Q: 有无xtls+splice+ws的计划？XTLS 原理上不支持 WS\n不带 TLS 的 WS 理论上可以支持类似 XTLS 的东西，目前没有实现它的计划\n或者 看看这里\n \n"},{"uri":"https://xtls.github.io/en/guide/command/","title":"Command parameters","tags":[],"description":"Project X Documents","content":" TIP\nXray uses go-style commands and parameters\n Get basic commands  You can run \u0026quot;xray help\u0026quot; to get all the basics of xray usage, as well as the available commands and instructions.\nXray is a platform for building proxies. Usage: xray \u0026lt;command\u0026gt; [arguments] The commands are: run Run xray with config, the default command version Show current version of Xray api Call an API in an Xray process tls TLS tools uuid Generate new UUIDs Use \u0026#34;xray help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. \nxray run  Usage:\nxray run [-c config.json] [-confdir dir] Run xray with config, the default command.\nThe -config=file, -c=file flags set the config files for Xray. Multiple assign is accepted.\nThe -confdir=dir flag sets a dir with multiple json config\nThe -format=json flag sets the format of config files. Default \u0026ldquo;json\u0026rdquo;.\nThe -test flag tells Xray to test config files only, without launching the server\n\nxray version  Usage:\nxray version Version prints the build information for Xray executables.\n\nxray api  Usage:\nxray api \u0026lt;command\u0026gt; [arguments] The commands are:\n restartlogger Restart the logger stats Get statistics statsquery Query statistics statssys Get system statistics adi Add inbounds ado Add outbounds rmi Remove inbounds rmo Remove outbounds  \nxray tls  Usage:\nxray tls \u0026lt;command\u0026gt; [arguments] The commands are:\n cert Generate TLS certificates ping Ping the domain with TLS handshake  \nxray uuid  Usage:\nxray uuid Generate new UUIDs.\n\nWhen -config is not specified, xray will successively try to load config.json from the following path:\n -working directory (working directory) Environment Variables from the path specified by xray.location.asset   "},{"uri":"https://xtls.github.io/en/config/base/dns/","title":"Built-in dns server","tags":[],"description":"Project X Documents","content":"DNS Server  If the DNS server module is configured for xray, it has two main purposes.\n  During the routing phase, the domain name will be resolved to an IP, and the IP obtained from the domain name resolution will be matched with rules for triage. Whether or not the domain name is resolved and triaged depends on the value of \u0026ldquo;domainStrategy\u0026rdquo; in the routing configuration module, and the built-in DNS server will only be used for DNS lookups if the following two values are set:\n \u0026ldquo;IPIfNonMatch\u0026rdquo;, when requesting a domain name, the domain will be matched and if no match is found, a DNS query will be performed using the built-in DNS server for the domain name and the IP address returned by the query will be used to perform a new IP routing match. \u0026ldquo;IPOnDemand\u0026rdquo;, when a match encounters any IP-based rule, resolves the domain name immediately to an IP for the match.    Resolve the destination address for connection.\n For example, if domainStrategy is set to UseIP in outbound of the freedom protocol, the outbound request will first resolve the domain name to an IP through the built-in server, and then connect.    TIP 1\nDNS lookup requests from the built-in DNS server are automatically forwarded according to the routing configuration.\n TIP 2\nOnly the most basic IP queries are supported (A and AAAA records).\n \nDNS processing flow  The DNS Server Configuration module allows you to configure multiple DNS servers and specify a priority match list.\n If the query matches a DNS server\u0026rsquo;s specified list of domain names, xray will use that DNS server for the query first. if there is no match, the query is performed in top-down order. only returns a list of IPs that match expectIPs.  The processing flow of the DNS server is illustrated below.\n\nDnsObject  DnsObject corresponds to the dns entry in the configuration file.\n{ \u0026#34;dns\u0026#34;: { \u0026#34;hosts\u0026#34;: { \u0026#34;baidu.com\u0026#34;: \u0026#34;127.0.0.1\u0026#34; }, \u0026#34;servers\u0026#34;: [ \u0026#34;8.8.8.8\u0026#34;, \u0026#34;8.8.4.4\u0026#34;, { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [\u0026#34;domain:xray.com\u0026#34;], \u0026#34;expectIPs\u0026#34;: [\u0026#34;geoip:cn\u0026#34;] }, \u0026#34;localhost\u0026#34; ], \u0026#34;clientIp\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns_inbound\u0026#34; } }  hosts: map{string: address}\n A static IP list whose values are a series of \u0026ldquo;domain names\u0026rdquo;: \u0026ldquo;addresses\u0026rdquo;. where the address can be either an IP or a domain name. When resolving a domain name, if the domain name matches one of the items in this list:\n When the address is an IP, the result will be the IP. When the address is a domain name, this domain name is used for IP resolution instead of the original domain name.  The format of a domain name can take several forms.\n Plain string: The rule takes effect when this string matches the target domain name in its entirety. For example, \u0026ldquo;xray.com\u0026rdquo; matches \u0026ldquo;xray.com\u0026rdquo; but not \u0026ldquo;www.xray.com\u0026rdquo;. Regular expression: starts with \u0026quot;regexp:\u0026quot; and the rest of the rule is a regular expression. The rule takes effect when this regular expression matches the target domain name. For example \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; matches \u0026ldquo;www.google.com\u0026rdquo; or \u0026ldquo;fonts.googleapis.com\u0026rdquo;, but not \u0026ldquo;google.com\u0026rdquo;. Sub-domain (recommended): starts with \u0026quot;domain:\u0026quot; and the rest is a domain name. This rule works when the domain name is the target domain or a subdomain of it. For example, \u0026ldquo;domain:xray.com\u0026rdquo; matches \u0026ldquo;www.xray.com\u0026rdquo;, \u0026ldquo;xray.com\u0026rdquo; but not \u0026ldquo;xray.com\u0026rdquo;. Substring: starts with \u0026quot;keyword:\u0026quot; and the rest of the string is a string. The rule takes effect when this string matches any part of the target domain name. For example, \u0026ldquo;keyword:sina.com\u0026rdquo; can match \u0026ldquo;sina.com\u0026rdquo;, \u0026ldquo;sina.com.cn\u0026rdquo; and \u0026ldquo;www.sina.com\u0026rdquo;, but not \u0026ldquo;sina.cn\u0026rdquo;. Predefined domain name list: starts with \u0026quot;geosite:\u0026quot; and the rest is a name such as geosite:google or geosite:cn. For a list of names and domains see [list of predefined domains](../routing/#List of predefined domains)。  servers: [string | ServerObject ]\n A list of DNS servers with two supported types: DNS addresses (in string form) and ServerObject.\nWhen its value is a DNS IP address, such as \u0026quot;8.8.8.8\u0026quot;, xray will use port 53 of this address for DNS lookups.\nWhen the value is \u0026quot;localhost\u0026quot;, it means that the local preset DNS configuration is used.\nWhen the value is of the form \u0026quot;https://host:port/dns-query\u0026quot;, such as \u0026quot;https://dns.google/dns-query\u0026quot;, xray will use DNS over HTTPS (RFC8484, abbreviated DOH) for the lookup. Some service providers have IP alias certificates that can be written directly in IP form, such as https://1.1.1.1/dns-query. Non-standard ports and paths can also be used, such as \u0026quot;https://a.b.c.d:8443/my-dns-query\u0026quot; .\nWhen the value is of the form \u0026quot;https+local://host:port/dns-query\u0026quot;, e.g. \u0026quot;https+local://dns.google/dns-query\u0026quot;, Xray will use DOH local mode for the query, i.e. the DOH request will not go through Routing/Outbound etc. components, and requests are made directly to the outside world to reduce time consumption. Generally suitable for use on the server side. Non-standard ports and paths can also be used.\nTIP 1\nWhen using localhost, local DNS requests are not controlled by Xray and additional configuration is required to enable DNS requests to be forwarded by xray.\n TIP 2\nDNS clients initialised with different rules are reflected in the Xray startup log at the info level, in patterns such as local DOH, remote DOH and udp.\n clientIp: string\n Used to notify the server when DNS queries are made to specify an IP location. Cannot be a private address.\ntag: string\n Query traffic from the built-in DNS, except for the localhost and DOHL_ patterns, can be matched at the route using inboundTag with this identifier.\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;1.2.3.4\u0026#34;, \u0026#34;port\u0026#34;: 5353, \u0026#34;domains\u0026#34;: [ \u0026#34;domain:xray.com\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }  address: address\n A list of DNS servers, of which two types are supported: DNS address (in string form) and ServerObject .\nWhen its value is a DNS IP address, such as \u0026ldquo;8.8.8.8\u0026rdquo;, xray will use port 53 of this address for DNS lookups.\nWhen the value is \u0026ldquo;localhost\u0026rdquo;, it means that the local preset DNS configuration is used.\nWhen the value is of the form \u0026ldquo;https://host:port/dns-query\u0026rdquo;, e.g. \u0026ldquo;https://dns.google/dns-query\u0026quot;, xray will use DNS over HTTPS (RFC8484, DOH for short) for the lookup. Some service providers have IP alias certificates and can write IP forms directly, such as https://1.1.1.1/dns-query. Non-standard ports and paths can also be used, such as \u0026ldquo;https://a.b.c.d:8443/my-dns-query\u0026quot;.\nWhen the value is of the form \u0026ldquo;https+local://host:port/dns-query\u0026rdquo;, e.g. \u0026ldquo;https+local://dns.google/dns-query\u0026rdquo;, xray will use DOH local mode for the query, i.e. the DOH request will not go through the Routing/ Outbound etc. components, and requests are made directly to the outside world to reduce time consumption. Generally suitable for use on the server side. Non-standard ports and paths can also be used.\n  port: number\n DNS server port, e.g. 53. This defaults to 53 by default. When using DOH mode this is not valid and the non-standard port should be specified in the URL.\ndomains: [string]\n A list of domains, this list contains domains that will be prioritised for lookup using this server. The format of the domain names is the same as in routing configuration.\nexpectIPs:[string]\n A list of IP ranges, in the same format as in route configuration.\nWhen this is configured, xray DNS checks the returned IP\u0026rsquo;s and only returns addresses that are included in the list of expectIPs.\nIf this is not configured, the IP address will be returned as is.\n"},{"uri":"https://xtls.github.io/en/config/base/","title":"Basic configuration module","tags":[],"description":"Project X Documents","content":" This section explains all the details of the Xray base configuration module. Basic configuration module   log:LogObject\n Logging configuration, which controls how the Xray outputs logs. api:ApiObject\n A number of API interfaces, which are provided for remote calls. dns: DnsObject\n The built-in DNS server. If this is not configured, the system\u0026rsquo;s DNS settings will be used. routing: RoutingObject\n Routing function. Rules can be set to split data into different outbounds. policy: PolicyObject\n Local policies. You can set different user levels and corresponding policy settings. inbounds: [ InboundObject ]\n An array, each element of which is an inbound connection configuration. outbounds: [ OutboundObject ]\n An array, each element of which is an outbound connection configuration. transport: TransportObject\n This is used to configure how xray establishes and uses network connections with other servers. stats: StatsObject\n This is used to configure the statistics of traffic data. reverse: ReverseObject\n Reverse Proxy. It can forward server-side traffic to the client, i.e. reverse traffic forwarding.\n"},{"uri":"https://xtls.github.io/en/documents/level-0/ch04-security/","title":"【第4章】安全防护篇","tags":[],"description":"小小白白话文","content":"4.1 为什么要做安全防护  Linux服务器的安全防护是一个纷繁复杂的巨大课题。无数的网站、APP、服务、甚至线下基础设施都建立在Linux的基石之上，这背后牵涉到巨大的经济利益和商业价值，当然也就就意味着黑灰产有巨大的攻击动力。但是这些服务是如此重要、根本不允许出现重大的安全漏洞。于是无数的运维专业人员都在安全攻防的战场上拼搏努力，这才让大家能享受到基本稳定的现代化数字生活。\n现在，你拥有了一台VPS，并且将会敞开他的数据访问渠道来达到流量转发的目标，那就相当于你已经置身于安全攻防战场的第一线、直面所有风险。但与此同时，新人由于知识和信息的不足，看待安全问题是总是难免两极分化：要么觉得轻如鸿毛和自己没有半点关系，要么觉得重于泰山甚至惶惶不可终日。\n  对于前者，我的建议是：安全无小事，尽量多查一些安全方面的信息，免得自己真的受了损失才后悔莫及\n  对于后者，我的建议是：不用紧张，我们的服务器仍不具有太高的价值、一般不会吸引到高水平的攻击，需要面对的基本都是一些自动化脚本的恶意扫描和登录尝试，跟着本文做一些基础的防护即可\n   4.2 具体的风险到底是什么  就像我们在《远程登录篇》配置的一样，任何人只需要知道【IP地址】+【端口】+【用户名】+【密码】这四个要素，就能登录你的VPS服务器。那很显然，这四要素的安全就是我们要防护的底线。我们来逐一分析：\n  【IP地址】：恶意脚本会随机尝试和扫描IP段，可以简单认为是公开信息、无法隐藏\n  【端口】：如果使用默认端口，那么【端口 = 22】\n  【用户名】：如果使用默认用户，那么【用户名 = root】\n  【密码】：密码不存在默认值，一定是由VPS后台随机生成或由你自行设置的。也就是说，如果你的服务器都是默认设置，则四要素中的三个已经是已知的，那么你整个服务器的安全，就全部寄托在一串小小的密码上了。这时有几种情况：\n  如果你用了VPS管理后台随机生成密码，它一般包含随机的十几个大小写混杂的字母和符号，相对比较安全\n  如果你为了好记、把密码改成了类似123456这种超弱的密码，破解你的VPS服务器可谓不费吹灰之力\n  如果你为了好记、把密码改成了比较复杂、但在别的地方用过的密码，其实也并不安全。你要明白黑客手里有作弊器，比如说密码表，包含数万、数十万、数百万甚至更多曾经泄漏的真实密码）\n    但你要明白，没有哪个黑客真的要坐在电脑前一次一次的尝试你的密码，全部的攻击尝试都是恶意脚本自动进行的，它会24小时不眠不休的工作。也许每天你酣睡之时，你的服务器都在经受着一轮又一轮的冲击。\n一旦密码被成功撞破，意味着你的四要素全部被攻击者掌握，恶意脚本就会快速登录服务器、获取服务器的最高 root 控制权、安装部署它的恶意服务，然后就可以用你的服务器来24小时做各种坏事（比如挖矿、传播病毒、发送垃圾邮件、欺诈邮件、做BT中继、甚至暗网公众节点等等等等）。如果恶意脚本比较克制，其实可以做到相当的隐蔽性。而新人一般也不会去观察留意VPS的登录记录、进程变化、CPU占用变化、流量变化等指标，你其实就很难发现自己被黑了。直到你的VPS服务商封禁你的账号、或者收到律师函为止。\n  别忘了，你获得VPS时大概率需要使用真实的支付信息，你登录各种网站、社交平台时也会留下你的IP地址，这些都与你的身份有直接或者间接的关系。于是，一旦这些坏事发生，它们就不可避免的与你产生了关联。\n   4.3 我们要做的安全防护有哪些  基于上述分析，我们要做的，自然就是对【端口】、【用户名】、【密码】这三要素进行加强，来降低被攻破的风险：\n 【端口】：将SSH远程登录端口修改为【非22端口】 （4.4） 【用户名】：建立【非root】的新用户、并禁用root用户SSH远程登录 （4.5、4.6） 【密码】：SSH启用RSA密钥验证登录、同时禁用密码验证登录 （4.7）  记得按顺序来，别把自己锁在门外了。\n 4.4 将SSH远程登录端口修改为非22端口  现在，我们来解决【端口 = 22】的问题。（注意：有些VPS服务商，默认的端口已经是非22端口，那么你可以忽略这一步，当然也可以跟着本文改成别的端口）\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-03 nano 文本编辑器   cmd-04 systemctl restart 重启某个服务      小小白白Linux基础配置文件\n   编号 配置文件位置 文件说明     conf-01 /etc/ssh/sshd_config SSH远程登录程序设置      我们要做的第一件事，当然就是【用nano这个文本编辑器打开SSH远程登录程序设置】，在Windows下，你会【找到文件并双击】，在Linux下该怎么办呢？仔细看看上面的命令说明，是不是就很简单了？没错，就是：\n# nano /etc/ssh/sshd_config   文件打开后，你就进入了nano的界面，稍微观察一下，你会发现，它把重要的快捷键都显示在屏幕下方了（下图红框内），直接开卷考试、不用死记硬背，是不是很贴心呢？\n  我们要做的第二件事，是【在打开的文件中找到Port这一项，并修改它的端口】。Port后面的数字就是SSH的端口，一般建议把它改成一个大于1024小于65535的整数（本文以9753为例）。请结合nano的快捷键，想一下该怎么操作呢？果然，你又说对了！就是：\n 使用 ctrl+w 进入搜索模式，然后输入 Port 22 并回车 删除 22 并改成 9753 说明：如果这一行开头有个#，证明这一行【不生效】（被注释掉了），你可像我一样在文件最后写一个不带#的，或者把#删掉就好。  注意： 本文以9753为例，就意味着随着本文的发布，这个端口会变成一个不大不小的特征，也许会被攻击者优先尝试、也许被GFW干扰、阻断。所以我强烈建议你用一个自己想到的其他端口，毕竟，你有6万多个端口可以自由选择。\n   我们要做的第三件事，是【保存文件并退出】\n 如果第3步你有仔细观察，就会发现保存并不是常见的 ctrl+s。 正确的快捷键：保存是 ctrl+o + 回车，退出是 ctrl+x    我们最后要做的事，是【重启ssh服务，使变更生效】\n# systemctl restart ssh   完整流程演示如下：\n  修改 PuTTY 配置\n现在新的端口已经生效，下次使用PuTTY登录时就要用9753了。所以现在请到PuTTY的设置中修改端口号码，然后保存Session。嗯，你应该知道去哪里改了吧？（如果不知道的话，要重读前面的内容了哦！）\n   4.5 建立非root的新用户  第二步，我们来解决【用户名 = root】的问题。\n首先你要理解， Linux系统中的root，不仅仅是一个管理员账号那么简单。它是整个系统的【根基】、是系统的主宰、至高无上的神。一旦root账号出现安全问题，整个系统都只能任人鱼肉、无处可逃。那么就跟随我进行操作吧：\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-05 adduser 给系统新增用户   cmd-06 apt install 安装某个软件   cmd-07 visudo 修改sudo权限设置专用编辑器      我们要做的第一件事，是【新增一个用户并设定登录密码】，名字你可以随便起，我这里以vpsadmin为例：\n# adduser vpsadmin 执行命令后，根据提示操作即可。请务必设置一个用户密码（别忘记设置密码时你时看不到 ****** 的）。之后系统会询问你一些用户的附加信息，这些就可以无视，一路回车即可。\n注意： 本文以vpsadmin为例，就意味着随着本文的发布，这个用户名也会变成一个不大不小的特征，也许会被攻击者优先尝试。所以和端口一样，我强烈建议你用一个自己想到的其他用户名。\n   完整流程演示如下：\n  我们要做的第二件事，是【安装sudo功能】（sudo 就是在关键时刻，让普通账户临时获得 root 的神力，战力全开拯救世界）\n# apt update \u0026amp;\u0026amp; apt install sudo 聪明的你大概已经发现，这一行命令其实是两个命令。前一半 apt update 你之前已经见过并且用过了，是去服务器刷新软件版本信息。后面的 apt install 就是这一次要用到的【安装命令】。两条连接在一起，就是让系统去【刷新可用的最新软件，然后安装最新版的sudo程序】。 \u0026amp;\u0026amp; 则是把两个命令连起来执行的意思。\n  我们要做的第三件事，是【把vpsadmin用户加入sudo名单里，让他有资格借用root的神力】\n# visudo 在 User Priviledge Specification 下加入一行 vpsadmin ALL=(ALL) NOPASSWD: ALL 即可。\n注意： 我要特别说明的是NOPASSWD这个设置，它的意思是vpsadmin用户临时使用root权限时，不用额外输入密码。这与一般的安全建议相反。我之所以如此推荐，是因为很多新人不顾危险坚持使用root账号就是因为用root时不用重复输入密码、觉得轻松。“两害相权取其轻”，我认为【直接用root用户的风险】大于【使用sudo时不用输密码的风险】，所以做了以上的建议。\n如果你希望遵守传统习惯、每次使用sudo时需要输入密码，那么这一行改成 vpsadmin ALL=(ALL:ALL) ALL 即可。\n   完整流程演示如下：\n   4.6 禁用root用户SSH远程登录    现在你已经逐渐熟悉Linux了，所以这次换你思考，我们要做的第一件事是什么呢？没错，还是【用nano编辑器打开SSH远程登录程序设置】，什么，你想不起来怎么操作了？那去复习一下上面的内容再回来吧！\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n# nano /etc/ssh/sshd_config   找到PermitRootLogin Yes这一项，然后把它后面的设定值改为no即可。还记得怎么操作吗？\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n 使用 ctrl+w 进入搜索模式，然后输入 PermitRootLogin 并回车 删除 yes 并改成 no    保存文件并退出。还记得怎么操作吗？\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 正确答案：\n 保存是 ctrl+o，然后 回车 确认 退出是 ctrl+x    重启ssh服务，让变更生效。还记得\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 算了直接公布正确答案：\n# systemctl restart ssh   完整流程演示如下：\n  下次通过PuTTY远程SSH登录的时候，root用户已无法连接，用户名就要换成vpsadmin了！方便起见，我们可以在PuTTY中把vpsadmin设置成默认登录用户名。（啰嗦君：别忘了保存Session）\n   4.7 使用RSA密钥登录并禁用密码登录  第三步，我们来解决【密码】可能被撞破的问题。\n前面我说过，黑客并不是很蠢的用穷举法破解你的密码，而是会用一些比如“密码表”的作弊手段。除非你用的是随机生成的超长密码（比如借助1Password，或者macOS的keychain等密码管理工具），否则很容易中招。\n超长随机密码虽然安全性有所提高，但是基本上无法记忆，手动输入也十分麻烦易错。为了解决这个困境，我们可以直接弃用【密码验证】方式，改用更安全的【密钥验证】。\n所谓的【密钥验证】，就是生成【一对】相关联的密钥文件（公钥和私钥），然后把【公钥】上传到VPS备用。每次登录时，SSH会将【公钥】和【私钥】进行匹配，若验证是正确的【密钥对】，则验证通过。（换言之，你无需记忆和输入复杂的密码，只要保护好【私钥】这个文件不外泄即可）\n那我们现在就来配置【密钥验证】吧！\n  运行PuTTYgen (PuTTY密钥生成器)。位置是 开始菜单 \u0026ndash;\u0026gt; 所有程序 \u0026ndash;\u0026gt; PuTTY (64-bit) \u0026ndash;\u0026gt; PuTTYgen\n  点击Generate开始生成（在界面空白处乱晃鼠标增加随机数）   你可以给私钥设置密码，增加一层安全性\n  点击 Save public key 保存公钥，文件名为 id_rsa.pub\n  点击 Save private key 保存私钥，文件名为 id_rsa (PuTTY私钥自带.ppk后缀)\n  最重要的，将上方红框内的内容，向下滚动全部复制出来并保存，文件名为 authorized_keys。（用vscode保存，默认会变成带txt后缀的文本文件，这没关系，之后上传VPS时我们会把后缀名去掉）     将公钥上传至VPS的vpsadmin用户下\n  这一步就需要用到之前准备的WinSCP了。\n  去官网下载并安装，会提示你导入PuTTY的设置，当然一键导入啦！   如果没有提示导入或者你已经提前安装好了，那按照下图进行配置即可   WinSCP左边的目录就是本地电脑上的文件夹和文件，请定位到密钥所在的文件夹\n  WinSCP右边的目录则是VPS服务器上的文件夹和文件，默认就在 /home/vpsadmin/ 文件夹，此时在请点击右下角 X hidden 来显示隐藏文件   在右边（VPS中）点击右键并新建文件夹，起名.ssh （注意有一个.）   将【公钥】authorized_keys上传到.ssh文件夹内   在上传时，将【公钥】从 authorized_keys.txt 改名为 authorized_keys（去掉.txt这个后缀名）   完整流程演示如下：     在VPS端设置SSH启用RSA密钥验证登录、同时禁用密码验证登录\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-08 sudo 用root权限运行某个命令   cmd-09 chmod 修改目标文件/文件夹的权限      SSH远程连接到VPS上（PuTTY）\n  修改 authorized_keys 文件权限为 600 （仅所有者可读可写）\n$ chmod 600 ~/.ssh/authorized_keys   修改 SSH 配置。这个我们已经用了很多次，但现在我们已经从无所不能的root变成了普通用户vpsadmin，此时的我们是没有权限直接编辑SSH配置的。这时候就需要使用sudo命令了：\n$ sudo nano /etc/ssh/sshd_config   找到(ctrl+w) PasswordAuthentication 改成 no\n  找到(ctrl+w) PubkeyAuthentication 改成 yes，然后保存(ctrl+o)退出(ctrl+x)\n  重启SSH服务。（啰嗦君：别忘了现在需要使用sudo来获得权限）\n$ sudo systemctl restart ssh   完整流程如下：\n    VPS端已经设置好了公钥，现在要给PuTTY指定私钥位置供登录时使用（啰嗦君：别忘了保存Session）\n  至此，【密钥登录】已成功开启、【密码验证】已成功关闭、并且还给PuTTY保存了默认的登录用户名和私钥。未来使用PuTTY登录时，载入VPS-SERVER配置后，点击Open就可以一键登录了。\n如果你给私钥设置了密码保护，登录时当然还需要输入这个密码才能使用密钥，如下图：\n   4.8 你的进度  到这里为止，你的VPS已经完成了【端口】、【用户名】、【密码】这三要素的基本安全保障，虽然远称不上固若金汤，但一般的恶意脚本应该已经无法对你造成伤害了！\n现在我们终于有了一个安全的系统基础，下一章，我们就可以开始逐步安装配置Xray需要的基础设施了！（什么基础设施呢？一个网页，一张证书）\nPROGRESS⬛⬛⬛⬛⬜⬜⬜⬜ 50%\n "},{"uri":"https://xtls.github.io/en/documents/level-2/","title":"Advanced Documentation","tags":[],"description":"Project X Documentation.","content":" This chapter contains advanced Xray experience sharing. If you are already familiar with Xray, and then the experience here can make your using to freed Xray more powerful performance. \n The entry of TProxy(Transparent Proxy) by @kirin\n Entry chapter of TProxy.\n Configure tutorial of TProxy(Transparent Proxy) by @BioniCosmos\n The full tutorial based on Xray\u0026rsquo;s TProxy configuration.\n [TProxy]Avoid Xray traffic through gid by @kirin\n In transparent proxy implemented by iptables/nftables, a new way to avoid Xray traffic.\n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/http/","title":"HTTP","tags":[],"description":"Project X 的文档.","content":"HTTP 协议。\nimportanthttp 协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。\nhttp inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n TIP\nhttp proxy 只能代理 tcp 协议，udp 系的协议均不能通过。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] } ] }  TIP\n目前 HTTP 协议 outbound 中 streamSettings 设置 security 和 tlsSettings 是生效的。\n servers: [ ServerObject ]\n HTTP 服务器列表，其中每一项是一个服务器配置，若配置多个，循环使用 (RoundRobin)。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;192.168.108.1\u0026#34;, \u0026#34;port\u0026#34;: 3128, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ] }  address: string\n HTTP 代理服务器地址，必填。\nport: int\n HTTP 代理服务器端口，必填。\nuser: [AccountObject]\n 一个数组，数组中每个元素为一个用户帐号。默认值为空。\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/en/config/transports/mkcp/","title":"mKCP","tags":[],"description":"Project X 的文档.","content":"mKCP 使用 UDP 来模拟 TCP 连接。\nmKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。\nTIP\n请确定主机上的防火墙配置正确\n KcpObject  KcpObject 对应传输配置的 kcpSettings 项。\n{ \u0026#34;mtu\u0026#34;: 1350, \u0026#34;tti\u0026#34;: 20, \u0026#34;uplinkCapacity\u0026#34;: 5, \u0026#34;downlinkCapacity\u0026#34;: 20, \u0026#34;congestion\u0026#34;: false, \u0026#34;readBufferSize\u0026#34;: 1, \u0026#34;writeBufferSize\u0026#34;: 1, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }, \u0026#34;seed\u0026#34;: \u0026#34;Password\u0026#34; }  mtu: number\n 最大传输单元（maximum transmission unit）\n请选择一个介于 576 - 1460 之间的值。\n默认值为 1350。\ntti: number\n 传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。\n请选译一个介于 10 - 100 之间的值。\n默认值为 50。\nuplinkCapacity: number\n 上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 5。\ndownlinkCapacity: number\n 下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，注意是 Byte 而非 bit。\n可以设置为 0，表示一个非常小的带宽。\n默认值 20。\nTIP\nuplinkCapacity 和 downlinkCapacity 决定了 mKCP 的传输速度。\n以客户端发送数据为例，客户端的 uplinkCapacity 指定了发送数据的速度，而服务器端的 downlinkCapacity 指定了接收数据的速度。两者的值以较小的一个为准。\n推荐把 downlinkCapacity 设置为一个较大的值，比如 100，而 uplinkCapacity 设为实际的网络速度。当速度不够时，可以逐渐增加 uplinkCapacity 的值，直到带宽的两倍左右。\n congestion: true | false\n 是否启用拥塞控制。\n开启拥塞控制之后，Xray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。\n默认值为 false\nreadBufferSize: number\n 单个连接的读取缓冲区大小，单位是 MB。\n默认值为 2。\nwriteBufferSize: number\n 单个连接的写入缓冲区大小，单位是 MB。\n默认值为 2。\nTIP\nreadBufferSize 和 writeBufferSize 指定了单个连接所使用的内存大小。\n在需要高速传输时，指定较大的 readBufferSize 和 writeBufferSize 会在一定程度上提高速度，但也会使用更多的内存。\n在网速不超过 20MB/s 时，默认值 1MB 可以满足需求；超过之后，可以适当增加 readBufferSize 和 writeBufferSize 的值，然后手动平衡速度和内存的关系。\n header: HeaderObject\n 数据包头部伪装设置\nseed: string\n 可选的混淆密码，使用 AES-128-GCM 算法混淆流量数据，客户端和服务端需要保持一致。\n本混淆机制不能用于保证通信内容的安全，但可能可以对抗部分封锁。 TIP\n目前测试环境下开启此设置后没有出现原版未混淆版本的封端口现象\n \nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  \n鸣谢   @skywind3000 发明并实现了 KCP 协议。 @xtaci 将 KCP 由 C 语言实现翻译成 Go。 @xiaokangwang 测试 KCP 与 Xray 的整合并提交了最初的 PR。  \n对 KCP 协议的改进  更小的协议头  原生 KCP 协议使用了 24 字节的固定头部，而 mKCP 修改为数据包 18 字节，确认（ACK）包 16 字节。更小的头部有助于躲避特征检查，并加快传输速度。\n另外，原生 KCP 的单个确认包只能确认一个数据包已收到，也就是说当 KCP 需要确认 100 个数据已收到时，它会发出 24 * 100 = 2400 字节的数据。其中包含了大量重复的头部数据，造成带宽的浪费。mKCP 会对多个确认包进行压缩，100 个确认包只需要 16 + 2 + 100 * 4 = 418 字节，相当于原生的六分之一。\n确认包重传  原生 KCP 协议的确认（ACK）包只发送一次，如果确认包丢失，则一定会导致数据重传，造成不必要的带宽浪费。而 mKCP 会以一定的频率重发确认包，直到发送方确认为止。单个确认包的大小为 22 字节，相比起数据包的 1000 字节以上，重传确认包的代价要小得多。\n连接状态控制  mKCP 可以有效地开启和关闭连接。当远程主机主动关闭连接时，连接会在两秒钟之内释放；当远程主机断线时，连接会在最多 30 秒内释放。\n原生 KCP 不支持这个场景。\n"},{"uri":"https://xtls.github.io/en/develop/protocols/mkcp/","title":"mKCP 协议","tags":[],"description":"Project X 的文档.","content":"mKCP 是流式传输协议，由 KCP 协议修改而来，可以按顺序传输任意的数据流。\n\n版本  mKCP 没有版本号，不保证版本之间兼容性。\n\n依赖  底层协议  mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。\n\n函数   fnv: FNV-1a 哈希函数  输入参数为任意长度的字符串； 输入出一个 32 位无符号整数；    \n通讯过程   mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。 mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。 每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。  \n数据格式  数据包     4 字节 2 字节 L 字节     认证信息 A 数据长度 L 片段部分    其中：\n 认证信息 A = fnv(片段部分），big endian； 片段部分可能包含多个片段；  \n数据片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len 字节     标识 Conv 指令 Cmd 选项 Opt 时间戳 Ts 序列号 Sn 未确认序列号 Una 长度 Len 数据    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x01 选项 Opt: 可选的值有：  0x00: 空选项 0x01: 对方已发出所有数据   时间戳 Ts: 当前片段从远端发送出来时的时间，big endian 序列号 Sn: 该数据片段时数据流中的位置，起始片段的序列号为 0，之后每个新片段按顺序加 1 未确认序列号 Una: 远端主机正在发送的，且尚未收到确认的最小的 Sn  \n确认片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节 2 字节 Len * 4 字节     标识 Conv 指令 Cmd 选项 Opt 窗口 Wnd 下一接收序列号 Sn 时间戳 Ts 长度 Len 已收到的序列号    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 常量 0x00 选项 Opt: 同上 窗口 Wnd: 远端主机可以接收的最大序列号 下一接收序列号 Sn: 远端主机未收到的数据片段中的最小序列号 时间戳 Ts: 远端主机最新收到的数据片段的时间戳，可用于计算延迟 已收到的序列号: 每个 4 字节，表示此序列号的数据已经确认收到  注释：\n 远程主机期待收到序列号 [Sn, Wnd) 范围内的数据  \n心跳片段     2 字节 1 字节 1 字节 4 字节 4 字节 4 字节     标识 Conv 指令 Cmd 选项 Opt 未确认序列号 Una 下一接收序列号 Sn 延迟 Rto    其中：\n 标识 Conv: mKCP 数据流的标识 指令 Cmd: 可选的值有  0x02: 远端主机强行终止会话 0x03: 正常心跳   选项 Opt: 同上 未确认序列号 Una: 同数据片段的 Una 下一接收序列号 Sn: 同确认片段的 Sn 延迟 Rto: 远端主机自己计算出的延迟  "},{"uri":"https://xtls.github.io/en/config/base/routing/","title":"Routing","tags":[],"description":"Project X Documents","content":"The routing function module allows inbound data to be sent out by different outbound connections according to different rules for the purpose of on-demand proxying.\nFor example, in a common use of splitting domestic and international traffic, xray can use internal mechanisms to determine traffic from different regions and send them to different outbound proxies.\nRoutingObject  RoutingObject corresponds to the routing entry in the configuration file.\n{ \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [], \u0026#34;balancers\u0026#34;: [] } }  domainStrategy: \u0026ldquo;AsIs\u0026rdquo; | \u0026ldquo;IPIfNonMatch\u0026rdquo; | \u0026ldquo;IPOnDemand\u0026rdquo;\n Domain name resolution policies, using different policies depending on the settings.\n \u0026quot;AsIs\u0026quot;: Use only domain names for routing. Default value. \u0026quot;IPIfNonMatch\u0026quot;: resolves the domain name to an IP (A record or AAAA record) to be matched again when the domain name does not match any rules.  When a domain name has multiple A records, attempts to match all of them until one of them matches a rule. the resolved IP only works for routing purposes, the original domain name is still used in forwarded packets.   \u0026quot;IPOnDemand\u0026quot;: when any IP-based rule is encountered during matching, the domain name is immediately resolved to IP for matching.  rules: [RuleObject]\n Corresponds to an array, each element of which is a rule.\nFor each connection, the route will be judged against these rules in turn, and when a rule is in effect, the connection will be forwarded to the outboundTag or balancerTag it specifies.\nTIP\nWhen no rule is matched, traffic is sent by default from the first outbound.\n balancers: [ BalancerObject ]\n An array, each element of which is a configuration of a load balancer.\nWhen a rule points to a load balancer, xray will select an outbound through this load balancer, which will then forward the traffic.\n\nRuleObject  { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;baidu.com\u0026#34;, \u0026#34;qq.com\u0026#34;, \u0026#34;geosite:cn\u0026#34; ], \u0026#34;ip\u0026#34;: [ \u0026#34;0.0.0.0/8\u0026#34;, \u0026#34;10.0.0.0/8\u0026#34;, \u0026#34;fc00::/7\u0026#34;, \u0026#34;fe80::/10\u0026#34;, \u0026#34;geoip:cn\u0026#34; ], \u0026#34;port\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;sourcePort\u0026#34;: \u0026#34;53,443,1000-2000\u0026#34;, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;source\u0026#34;: [ \u0026#34;10.0.0.1\u0026#34; ], \u0026#34;user\u0026#34;: [ \u0026#34;love@xray.com\u0026#34; ], \u0026#34;inboundTag\u0026#34;: [ \u0026#34;tag-vmess\u0026#34; ], \u0026#34;protocol\u0026#34;: [ \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;, \u0026#34;bittorrent\u0026#34; ], \u0026#34;attrs\u0026#34;: \u0026#34;attrs[\u0026#39;:method\u0026#39;] == \u0026#39;GET\u0026#39;\u0026#34;, \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;balancerTag\u0026#34;: \u0026#34;balancer\u0026#34; } \nimportantWhen multiple attributes are specified at the same time, these attributes need to be satisfied at the same time for the current rule to take effect.\n type: \u0026ldquo;field\u0026rdquo;\n Currently only the option \u0026quot;field\u0026quot; is supported.\ndomain: [string]\n An array where each item of the array is a match for a domain name. There are several forms.\n Plain string: The rule takes effect when this string matches any part of the target domain name. For example, \u0026ldquo;sina.com\u0026rdquo; can match \u0026ldquo;sina.com\u0026rdquo;, \u0026ldquo;sina.com.cn\u0026rdquo; and \u0026ldquo;www.sina.com\u0026rdquo;, but not \u0026ldquo;sina.cn\u0026rdquo;. Regular expression: starts with \u0026quot;regexp:\u0026quot; and the rest is a regular expression. The rule takes effect when this regular expression matches the target domain name. For example \u0026ldquo;regexp:\\\\.goo.*\\\\.com$\u0026rdquo; matches \u0026ldquo;www.google.com\u0026rdquo; or \u0026ldquo;fonts.googleapis.com\u0026rdquo;, but not \u0026ldquo;google.com\u0026rdquo;. Subdomain (recommended): starts with \u0026quot;domain:\u0026quot; and the remainder is a domain name. This rule takes effect when this domain name is the target domain or a subdomain of it. For example, domain:xray.com matches www.xray.com, xray.com, but not wxray.com. Full match: starts with \u0026quot;full:\u0026quot; and the rest is a domain name. The rule takes effect when this domain name matches the target domain name in full. For example, \u0026ldquo;full:xray.com\u0026rdquo; matches \u0026ldquo;xray.com\u0026rdquo; but not \u0026ldquo;www.xray.com\u0026rdquo;. Predefined domain name list: starts with \u0026quot;geosite:\u0026quot; and the rest is a name, e.g. geosite:google or geosite:cn. See [list of predefined domains](# list of predefined domains) for a list of names and domains. Load the domain name from a file: in the form of \u0026quot;ext:file:tag\u0026quot;, must start with ext: (lowercase) followed by the file name and tag, the file is stored in [resource directory](. /env#resource file path) in the same format as geosite.dat, and the tag must be present in the file. TIP\n\u0026quot;ext:geoip.dat:cn\u0026quot; is equivalent to \u0026quot;geoip:cn\u0026quot;\n   ip: [string]\n An array where each element of the array represents an IP range. This rule takes effect when an element matches the target IP. There are several forms.\n IP: in the form of \u0026quot;127.0.0.1\u0026quot;. CIDR: in the form of \u0026quot;10.0.0.0/8\u0026quot;. Predefined IP list: This list is preconfigured in each Xray installation package and is named geoip.dat. It is used as \u0026quot;geoip:cn\u0026quot; and must start with geoip: (lower case) followed by a two-character country code to support almost any country with internet access.  Special value: \u0026quot;geoip:private\u0026quot;, contains all private addresses, e.g. 127.0.0.1.   Load IP from file: shaped like \u0026quot;ext:file:tag\u0026quot;, must start with ext: (lowercase) followed by the file name and tag, file is stored in [resource directory](../env#resource file path) in the same format as geoip.dat The tag must be present in the file.  port：number | string\n The target port range, which has three forms.\n \u0026quot;a-b\u0026quot;: both a and b are positive integers and less than 65536. this range is a back-and-forth closed interval, and this rule takes effect when the target port falls within this range. a: a is a positive integer and is less than 65536. this rule takes effect when the target port is a. A mixture of the above two forms, separated by a comma \u0026ldquo;,\u0026rdquo;. For example: \u0026quot;53,443,1000-2000\u0026quot;.  sourcePort：number | string\n Source port, in three forms.\n \u0026quot;a-b\u0026quot;: both a and b are positive integers and less than 65536. this range is a back-and-forth closed interval, and this rule takes effect when the target port falls within this range. a: a is a positive integer and is less than 65536. this rule takes effect when the target port is a. A mixture of the above two forms, separated by a comma \u0026ldquo;,\u0026rdquo;. For example: \u0026quot;53,443,1000-2000\u0026quot;.  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n The available values are \u0026ldquo;tcp\u0026rdquo;, \u0026ldquo;udp\u0026rdquo; or \u0026ldquo;tcp,udp\u0026rdquo;. This rule takes effect when the connection method is the specified method.\nsource: [string]\n An array where each element of the array represents an IP range. This rule takes effect when an element matches the target IP. There are several forms.\n IP: in the form of \u0026quot;127.0.0.1\u0026quot;. CIDR: in the form of \u0026quot;10.0.0.0/8\u0026quot;. Predefined IP list: This list is preconfigured in each Xray installation package and is named geoip.dat. It is used as \u0026quot;geoip:cn\u0026quot; and must start with geoip: (lower case) followed by a two-character country code to support almost any country with internet access.  Special value: \u0026quot;geoip:private\u0026quot;, contains all private addresses, e.g. 127.0.0.1.   Load IP from file: shaped like \u0026quot;ext:file:tag\u0026quot;, must start with ext: (lowercase) followed by the file name and tag, file is stored in [resource directory](../env#resource file path) in the same format as geoip.dat The tag must be present in the file.  user: [string]\n An array, where each element of the array is an email address. This rule takes effect when an element matches the source user.\ninboundTag: [string]\n An array, each element of which is an identifier. This rule takes effect when an element matches the identifier of an inbound protocol.\nprotocol: [ \u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;bittorrent\u0026rdquo; ]\n An array, each element of which represents a protocol. This rule takes effect when a protocol matches the protocol type of the current connection. TIP\nThe sniffing option in the inbound proxy must be enabled to sniff out the protocol type used by the connection.\n attrs: string\n A script that detects the value of an attribute of the traffic. This rule takes effect when this script returns a true value.\nThe script language is Starlark and its syntax is a subset of Python. The script accepts a global variable attrs, which contains traffic-related attributes.\nCurrently only http inbound proxies will set this attribute.\nExamples.\n Detecting HTTP GET: \u0026quot;attrs[':method'] == 'GET'\u0026quot; Detect HTTP Path: \u0026quot;attrs[':path'].startswith('/test')\u0026quot; Detect Content Type: \u0026quot;attrs['accept'].index('text/html') \u0026gt;= 0\u0026quot;  outboundTag: string\n Corresponds to an outbound tag.\nbalancerTag: string\n Corresponds to a balancer tag.\nTIP\nbalancerTag and outboundTag must be either. When both are specified, outboundTag takes effect.\n \nBalancerObject  Load Balancer Configuration. When a load balancer is in effect, it will select the most appropriate outbound for traffic forwarding from the specified outbound, as configured.\n{ \u0026#34;tag\u0026#34;: \u0026#34;balancer\u0026#34;, \u0026#34;selector\u0026#34;: [] }  tag: string\n The identifier of this load balancer to match the balancerTag in the RuleObject.\nselector: [ string ]\n An array of strings, each of which will be used to match against the prefix of the outbound identifier. Of the following outbound identifiers: [ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;ba\u0026quot; ], \u0026quot;selector\u0026quot;: [\u0026quot;a\u0026quot;] will match to [ \u0026quot;a\u0026quot;, \u0026quot;ab\u0026quot; ].\nIf more than one outbound is matched, the load balancer will now randomly select one of them as the final outbound.\n\nList of predefined domains  This list is pre-populated in every xray installation package with the file name geosite.dat. This file contains a number of common domain names, used as: geosite:filename, e.g. geosite:google indicates a route filter or DNS filter for domains within the file that match those contained within google.\nCommon domain names are.\n category-ads: Contains common advertising domains. category-ads-all: contains common ad domains, as well as the ad provider\u0026rsquo;s domain name. cn: equivalent to a combination of geolocation-cn and tld-cn. apple: contains most of the domains owned by Apple. google: Contains most of the domain names under the Google umbrella. microsoft: Contains most of the domain names under the Microsoft umbrella. facebook: Includes most of the domain names owned by Facebook. twitter: Contains most of the domains owned by Twitter. telegram: contains most of Telegram\u0026rsquo;s domain names. geolocation-cn: Contains common mainland site domains. geolocation-!cn: Includes common non-continental domain names, also includes tld-!cn. tld-cn: contains the top-level domain names managed by CNNIC for mainland China, such as those ending in .cn, . China. tld-!cn: contains top-level domain names not used in mainland China, such as those ending with .hk (Hong Kong), .tw (Taiwan), .jp (Japan), .sg (Singapore), .us (USA), .ca (Canada), etc.  "},{"uri":"https://xtls.github.io/en/config/inbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n InboundConfigurationObject { \u0026#34;auth\u0026#34;: \u0026#34;noauth\u0026#34;, \u0026#34;accounts\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; } ], \u0026#34;udp\u0026#34;: false, \u0026#34;ip\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;userLevel\u0026#34;: 0 }  auth: \u0026ldquo;noauth\u0026rdquo; | \u0026ldquo;password\u0026rdquo;\n Socks 协议的认证方式，支持 \u0026quot;noauth\u0026quot; 匿名方式和 \u0026quot;password\u0026quot; 用户密码方式。\n默认值为 \u0026quot;noauth\u0026quot;。\naccounts: [ AccountObject ]\n 一个数组，数组中每个元素为一个用户帐号。\n此选项仅当 auth 为 password 时有效。\n默认值为空。\nudp: true | false\n 是否开启 UDP 协议的支持。\n默认值为 false。\nip: address\n 当开启 UDP 时，Xray 需要知道本机的 IP 地址。\n默认值为 \u0026quot;127.0.0.1\u0026quot;。\nuserLevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\nAccountObject  { \u0026#34;user\u0026#34;: \u0026#34;my-username\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;my-password\u0026#34; }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\n"},{"uri":"https://xtls.github.io/en/documents/level-1/work/","title":"The Working Mode of Xray","tags":[],"description":"Project X Documentation.","content":"Single Server mode  The same as the other network proxy tools, you need a configured Xray Server. And install \u0026amp; configure Xray client on your device. After that, you will have a smooth Internet Access.\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(Firewall); B -.- C(Blocked Website); A -- D(Xray/VPS); D -- C; A -- E(Accessible Website);  An Xray Server can simutanously support multiple devices and devices can using different proxy protocol to access. Meanwhile, via the correct configuation , Xray can recognize and distingush the traffic which need to proxy or not. Direct data do not need to detour.\n\nBridge Mode  If you don\u0026rsquo;t like to set router on each device, you can set a transit server for reciving all the traffic from the Client, and do forwarding judgment on server.\nmermaid.initialize({startOnLoad:true}); graph LR; A(PC) -.- B(Firewall); B -.- C(Blocked Website); A -- D(Inside-firewall VPS); D -- E(Outside-firewall VPS); E -- C; D -- F(Accessible Website);  \nWorking Principle  Before configure Xray, it\u0026rsquo;s a good idea to acknowledge the Working Principle of Xray, the following is a schematic diagram of the internal structure of a single Xray process. Multiple Xrays are independent of each other and do not affect each other.\nmermaid.initialize({startOnLoad:true}); graph LR; A1(inbound) -- D(Dispatcher / Router / DNS); A2(inbound) -- D; A3(inbound) -- D; A4(inbound) -- D; D -- B1(outbound); D -- B2(outbound); D -- B3(outbound); D -- B4(outbound);   In order to work successfully, it need to configure at least one Inbound Connection and one Outbound Connection.  Inbound connections are responsible for communicating with clients (such as browsers)：  Inbound Connection can usually configure User authentication, such as ID , password and so on; After the inbound connection receives the data, it will be handed over to the Dispatcher for distribution；   Outbound connection is responsible for sending data to the server, such as Xray on another host. When there are multiple outbound connections, you can configure Routing to specify that a certain type of traffic is sent by a certain outbound connection. When necessary, the router will query DNS for more information to make judgments.    "},{"uri":"https://xtls.github.io/en/documents/","title":"Using Experiences","tags":[],"description":"Project X Documentation.","content":" This chapter contains various using skills and experiences, mostly come from in actual use. Beginner Vernacular Documentation Giving Guidance Experience to Beginner\nPlease Click Vernacular Documentation to look through\n Getting Started Skills After you have the basics, you can explore more ways to use it through Getting Started Skills  Advanced Documentation Using Experience for Guiding Advanced Users\nClick Advanced Documentation to look through\n  \nThank you very much for sharing your skills and experience selflessly, making Xray increasingly powerful.\n "},{"uri":"https://xtls.github.io/en/faq/tproxy/","title":"透明代理相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 我搭建了透明代理给我和我同宿舍/隔壁宿舍的同学用, 日志中出现很多 too many open files .怎么办? 急,在线等.让你的同学少用BT过代理下载American Video 在 /etc/systemd/system/xray.service 的 [Service] 下加 LimitNPROC=10000 和 LimitNOFILE=1000000.\n Q: sniffing的具体功能是什么，什么时候发挥作用?sniffing流量探测主要作用是用在透明代理等用途.\n他的一个典型工作流程是这样的.\n比如你有一个设备上网,去访问abc.com, 首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4发起连接.\n 透明代理不设置嗅探的话,收到的连接请求是1.2.3.4,是不能走域名规则的路由分流的. 透明代理设置了sniffing,处理这个流量时,会从这个流量的数据中,嗅探出域名,abc.com. 然后把1.2.3.4重置为abc.com. 路由就可以根据域名进行符合域名规则的分流, 或者做更多的事情.  因为变成了一个向abc.com请求的连接,就可以做更多的事情,包括路由域名规则分流, 重新做DNS解析等等\u0026hellip;\n另一个sniffing的作用是可以嗅探BT流量的标识,把流量归类成BT类型. 然后可以在路由中根据BT类型来做规则,比如服务端用来拦截BT流量,比如客户端把BT流量固定发送到某个VPS去代理等.\n "},{"uri":"https://xtls.github.io/en/guide/document/","title":"Usage Documents","tags":[],"description":"Project X Documents","content":"View documents   You can use the menu on the left to select the relevant category you want to see.\n  Once you have selected a menu item, you can quickly switch between the articles in that category in the navigation bar at the top of the text area.\n   When viewing an article, you can quickly switch to one of the headings by using the list of headings on the right.\n   Improve documents  The documentation for Project X is maintained on github.\nYou can submit your changes to the documents by following these steps:\n  Open the repository from project X documentation repository, click on fork in the top right corner, and fork a copy of the documentation repository image to your own github repository.\n  You can use any tool you like to get a clone of the document from your cloned repository, e.g.:\n    git clone https://github.com/yours/XTLS.github.io   Create a new branch based on the main branch, e.g.:    git checkout -b your-branch    Make changes on the new branch, and commit the changes when finished\n  Push the created branch to your repository\n    git push -u origin your-branch    Open github and click \u0026lsquo;pull request\u0026rsquo; to send a PR to the project X document repository.\n  In the title and body of the PR, summarize what is added/modified in the PR, etc.\n  Wait for a response, if the PR is merged, the changes you have made will be presented directly on the project X documentation site.\n  "},{"uri":"https://xtls.github.io/en/documents/level-0/ch05-webpage/","title":"【第5章】网站建设篇","tags":[],"description":"小小白白话文","content":"5.1 为什么要做一个网站？  新人也许会迷惑，为什么科学上网还要建一个网站？我不会编程啊，是不是特别麻烦？\n先回答第一个问题，建网站的原因有：\n 申请合法的TLS证书（非常重要） 提供合理的回落，防止主动探测攻击，提高安全性 建设一个伪装站（如博客、私人网盘、多媒体网站、游戏网站等），直接访问时有合理的前台，使流量使用看上去更合理。  再回答第二个问题：\n 本文作为演示，仅仅使用了一个最简单的【单文件html页面 + Nginx】来搭建，以此完成上面的目标，所以【非常简单】 这个网站完全可以不仅仅是伪装，而是真的做大做强，这个复杂性就完全取决于你了 对于“伪装”和“网站运营”这个目标，需要的就是各不相同、秀出真我，需要的同学可以自行搜索学习。这个内容已经完全偏离了科学上网，本文就不深入解析了。   5.2 登录VPS、安装运行Nginx    这里用到的，都是之前已经详解过的命令，所以就不重复讲解了。看不懂的同学可以看看前面的章节哦。\n$ sudo apt update \u0026amp;\u0026amp; sudo apt install nginx   完成后，Nginx已经自动运行。此时打开Windows上的浏览器并输入 http://100.200.300.400:80，若看到下图的界面就说明Nginx已经正常在运行了。\n   5.3. 创建一个最简单的网页    小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-10 mkdir 新建文件夹   cmd-11 systemctl reload 重新加载某个服务      小小白白Linux基础配置文件：\n   编号 配置文件位置 文件说明     conf-02 /etc/nginx/nginx.conf Nginx程序设置      创建一个网站专用的文件夹/home/vpsadmin/www/webpage/并建立网页文件index.html\n$ mkdir -p ~/www/webpage/ \u0026amp;\u0026amp; nano ~/www/webpage/index.html   把下面的内容完整的复制进去，然后保存(ctrl+o)退出(ctrl+x)\n\u0026lt;html\u0026gt; \u0026lt;!-- Text between angle brackets is an HTML tag and is not displayed. Most tags, such as the HTML and /HTML tags that surround the contents of a page, come in pairs; some tags, like HR, for a horizontal rule, stand alone. Comments, such as the text you\u0026#39;re reading, are not displayed when the Web page is shown. The information between the HEAD and /HEAD tags is not displayed. The information between the BODY and /BODY tags is displayed.--\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Enter a title, displayed at the top of the window.\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;!-- The information between the BODY and /BODY tags is displayed.--\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Enter the main heading, usually the same as the title.\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Be \u0026lt;b\u0026gt;bold\u0026lt;/b\u0026gt; in stating your key points. Put them in a list: \u0026lt;/p\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;The first item in your list\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;The second item; \u0026lt;i\u0026gt;italicize\u0026lt;/i\u0026gt; key words\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;Improve your image by including an image. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;img src=\u0026#34;https://i.imgur.com/SEBww.jpg\u0026#34; alt=\u0026#34;A Great HTML Resource\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Add a link to your favorite \u0026lt;a href=\u0026#34;https://www.dummies.com/\u0026#34;\u0026gt;Web site\u0026lt;/a\u0026gt;. Break up your page with a horizontal rule or two. \u0026lt;/p\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;p\u0026gt;Finally, link to \u0026lt;a href=\u0026#34;page2.html\u0026#34;\u0026gt;another page\u0026lt;/a\u0026gt; in your own Web site.\u0026lt;/p\u0026gt; \u0026lt;!-- And add a copyright notice.--\u0026gt; \u0026lt;p\u0026gt;\u0026amp;#169; Wiley Publishing, 2011\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   修改 nginx.conf 并重启 Nginx 服务，将80端口的http访问定位到刚才建立的 html 页面上\n  修改 nginx.conf 。\n$ sudo nano /etc/nginx/nginx.conf   将下面一段，添加在 http{} 内，然后保存(ctrl+o)退出(ctrl+x)。（记得将域名替换为之前准备好的、包含二级域名的真实域名）\nserver { listen 80; server_name 二级域名.你的域名.com; root /home/vpsadmin/www/webpage; index index.html; }   让 nginx 重新载入配置使其生效\nsudo systemctl reload nginx   完整的设置流程如下：\n  此时如果你访问 http://二级域名.你的域名.com，你看到这样的页面则说明成功：\n     5.4 你的进度  至此，Xray的第一个基础设施【网页】已经就位，我们马上就进入第二个基础设施【证书】吧！\nPROGRESS⬛⬛⬛⬛⬛⬜⬜⬜ 62.5%\n "},{"uri":"https://xtls.github.io/en/config/transports/h2/","title":"HTTP/2","tags":[],"description":"Project X 的文档.","content":"基于 HTTP/2 的传输方式。\n它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。\n由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。\nTIP\n当前版本的 HTTP/2 的传输方式并不强制要求服务器端有 TLS 配置.\n这使得可以在特殊用途的分流部署环境中，由外部网关组件完成 TLS 层对话，Xray 作为后端应用，网关和 Xray 间使用称为 h2c 的明文 http/2 进行通讯。\n HttpObject  HttpObject 对应传输配置的 httpSettings 项。\n{ \u0026#34;host\u0026#34;: [\u0026#34;xray.com\u0026#34;], \u0026#34;path\u0026#34;: \u0026#34;/random/path\u0026#34; }  host: [string]\n 一个字符串数组，每一个元素是一个域名。\n客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。\npath string\n HTTP 路径，由 / 开头, 客户端和服务器必须一致。\n默认值为 \u0026quot;/\u0026quot;。\n"},{"uri":"https://xtls.github.io/en/config/inbound-protocols/","title":"Inbounds 可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于 Inbounds 的协议及具体配置细节. 协议列表   Dokodemo-door\n Dokodemo door（任意门）可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。 HTTP\n HTTP 协议 Socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 VLESS\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，，可以作为 Xray 客户端和服务器之间的桥梁。 Trojan\n Trojan 协议 Shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/socks/","title":"Socks","tags":[],"description":"Project X 的文档.","content":"标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。\nimportantsocks 协议没有对传输加密，不适宜经公网中传输\nsocks inbound 更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  servers: [ ServerObject ]\n Socks 服务器列表，其中每一项是一个服务器配置。\nServerObject { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;users\u0026#34;: [ { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务器地址, 必填\nTIP\n仅支持连接到 Socks 5 服务器。\n port: number\n 服务器端口, 必填\nusers: [ UserObject ]\n 一个数组表示的用户列表，数组中每个元素为一个用户配置。\n当列表不为空时，Socks 客户端会使用用户信息进行认证；如未指定，则不进行认证。\n默认值为空。\n\nUserObject  { \u0026#34;user\u0026#34;: \u0026#34;test user\u0026#34;, \u0026#34;pass\u0026#34;: \u0026#34;test pass\u0026#34;, \u0026#34;level\u0026#34;: 0 }  user: string\n 用户名，字符串类型。必填。\npass: string\n 密码，字符串类型。必填。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0\n"},{"uri":"https://xtls.github.io/en/config/inbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nInboundConfigurationObject { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户 ClientObject。\n decryption: \u0026ldquo;none\u0026rdquo;\n 现阶段需要填 \u0026quot;none\u0026quot;，不能留空。 若未正确设置 decryption 的值，使用 Xray 或 -test 时会收到错误信息。\n注意这里是 decryption，和 clients 同级。 decryption 和 vmess 协议的 encryption 的位置不同，是因为若套一层约定加密，服务端需要先解密才能知道是哪个用户。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\n ClientObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; }  id: string\n VLESS 的用户 ID，必须是一个合法的 UUID，你也可以使用命令 xray uuid 生成它。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nemail: string\n 用户邮箱，用于区分不同用户的流量（会体现在日志、统计中）。\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前入站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式，此时客户端仅可选择 xtls-rprx-origin 和 xtls-rprx-origin-udp443 这两种流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-direct：推荐，所有平台皆可使用的典型流控方式，此时客户端可选择任何流控模式  注意\n当 flow 被指定时，还需要将该入站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n  配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（按实现时间先后顺序排列）\n 新型协议回落模式解析  In progress\n VLESS 分享链接标准  In progress\n"},{"uri":"https://xtls.github.io/en/faq/fallback/","title":"回落相关问题","tags":[],"description":"Project X 的文档.","content":" Q: 回落是个啥?好吃吗?Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享\n点此查看详情 回落\n Q: 为什么我回落以后nginx日志的IP是 127.0.0.1?需要开启 proxy protocol. 参见fallbacks配置的xver参数\n Q: 我还是上一题的提问者, 那么我如何使用proxy protocol,达到所有日志都有源IP的目的呢?等待好心人写一篇小小白白话文\n Q: Wordpress 是 Mixed Content, 回落到配置的Wordpress看起来怪怪的, 怎么办?@Ardentwheel :\n需要在nginx的配置中加入以下内容，才可以修复\nadd_header Content-Security-Policy \u0026#34;upgrade-insecure-requests\u0026#34;; \n "},{"uri":"https://xtls.github.io/en/develop/","title":"开发指南","tags":[],"description":"Project X 的文档.","content":"In progress\n"},{"uri":"https://xtls.github.io/en/config/base/policy/","title":"本地策略","tags":[],"description":"Project X 的文档.","content":"本地策略，可以设置不同的用户等级和对应的策略设置，比如连接超时设置。Xray 处理的每一个连接都对应一个用户，按照用户的等级（level）应用不同的策略。\nPolicyObject  PolicyObject 对应配置文件的 policy 项。\n{ \u0026#34;policy\u0026#34;: { \u0026#34;levels\u0026#34;: { \u0026#34;0\u0026#34;: { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 4 } }, \u0026#34;system\u0026#34;: { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false } } }  level: map{string: LevelPolicyObject}\n 一组键值对，每个键是一个字符串形式的数字（JSON 的要求），比如 \u0026quot;0\u0026quot;、\u0026quot;1\u0026quot; 等，双引号不能省略，此数字对应用户等级。每一个值是一个 LevelPolicyObject.\nTIP\n每个入站出站代理现在都可以设置用户等级，Xray 会根据实际的用户等级应用不同的本地策略。\n system: SystemPolicyObject\n Xray系统级别的策略\n\nLevelPolicyObject  { \u0026#34;handshake\u0026#34;: 4, \u0026#34;connIdle\u0026#34;: 300, \u0026#34;uplinkOnly\u0026#34;: 2, \u0026#34;downlinkOnly\u0026#34;: 5, \u0026#34;statsUserUplink\u0026#34;: false, \u0026#34;statsUserDownlink\u0026#34;: false, \u0026#34;bufferSize\u0026#34;: 10240 }  handshake: number\n 连接建立时的握手时间限制。单位为秒。默认值为 4。在入站代理处理一个新连接时，在握手阶段如果使用的时间超过这个时间，则中断该连接。\nconnIdle: number\n 连接空闲的时间限制。单位为秒。默认值为 300。inbound/outbound处理一个连接时，如果在 connIdle 时间内，没有任何数据被传输（包括上行和下行数据），则中断该连接。\nuplinkOnly: number\n 当连接下行线路关闭后的时间限制。单位为秒。默认值为 2。当服务器（如远端网站）关闭下行连接时，出站代理会在等待 uplinkOnly 时间后中断连接。\ndownlinkOnly: number\n 当连接上行线路关闭后的时间限制。单位为秒。默认值为 5。当客户端（如浏览器）关闭上行连接时，入站代理会在等待 downlinkOnly 时间后中断连接。\nTIP\n在 HTTP 浏览的场景中，可以将 uplinkOnly 和 downlinkOnly 设为 0，以提高连接关闭的效率。\n statsUserUplink: true | false\n 当值为 true 时，开启当前等级的所有用户的上行流量统计。\nstatsUserDownlink: true | false\n 当值为 true 时，开启当前等级的所有用户的下行流量统计。\nbufferSize: number\n 每个连接的内部缓存大小。单位为 kB。当值为 0 时，内部缓存被禁用。\n默认值:\n 在 ARM、MIPS、MIPSLE 平台上，默认值为 0。 在 ARM64、MIPS64、MIPS64LE 平台上，默认值为 4。 在其它平台上，默认值为 512。  TIP\nbufferSize 选项会覆盖 环境变量中 Xray.ray.buffer.size 的设定。\n -- \nSystemPolicyObject  { \u0026#34;statsInboundUplink\u0026#34;: false, \u0026#34;statsInboundDownlink\u0026#34;: false, \u0026#34;statsOutboundUplink\u0026#34;: false, \u0026#34;statsOutboundDownlink\u0026#34;: false }  statsInboundUplink: true | false\n 当值为 true 时，开启所有入站代理的上行流量统计。 statsInboundDownlink: true | false\n 当值为 true 时，开启所有入站代理的下行流量统计。 statsOutboundUplink: true | false\n 当值为 true 时，开启所有出站代理的上行流量统计。 statsOutboundDownlink: true | false\n 当值为 true 时，开启所有出站代理的下行流量统计。\n"},{"uri":"https://xtls.github.io/en/documents/level-0/ch06-certificates/","title":"【第6章】证书管理篇","tags":[],"description":"小小白白话文","content":"6.1 申请TLS证书  接下来我们要做的，是为我们的域名申请一个真实的TLS证书，使网站具备标准TLS加密的能力及HTTPS访问的能力。这就是Xray等现阶段安全代理工具确保流量充分加密最重要的工具。\n注意： 请不要轻易使用自签证书。它并没有让操作简单太多，但增加了无谓的风险（如中间人攻击）。\n 这里我会使用一个叫做 acme.sh 的证书管理工具，它简单、轻量、高效，并可完成证书自动更新。\n另外，我相信，现在你已经逐渐熟悉了Linux的基础操作，所以已经多次出现的命令从本章开始不再重复截图、只做简单的描述。如果实在想不起来怎么用的话，就稍微复习一下前面的章节吧。\n 6.2 安装 acme.sh    小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-12 wget 访问（或下载）某个网页文件   cmd-13 acme.sh acme.sh证书管理相关的命令      运行安装脚本\n$ wget -O - https://get.acme.sh | sh   让 acme.sh 命令生效\n$ . .bashrc   开启 acme.sh 的自动升级\n$ acme.sh --upgrade --auto-upgrade   到这一步的完整流程如下图：\n   6.3 申请证书    申请证书的命令如下，本文以ECC证书为例：\n$ acme.sh --issue -d 二级域名.你的域名.com -w /home/vpsadmin/www/webpage --keylength ec-256  说明： 目前没有任何理由不用ECC证书，因为它的Keysize更小，意味着安全性的提升和加密解密速度的加快。如 ECC-256bit 的强度大约相当于 RSA-3072bit，何乐而不为呢？当然有人说ECC证书握手会明显更快，这我觉得就有些夸张了，因为RSA握手也没有太慢，就算有差别应该也是毫秒级，很难直接感知。\n   你最终应该看到类似这样的提示：\nvpsadmin@vps-server:~$ acme.sh --issue -d 二级域名.你的域名.com -w /home/vpsadmin/www/webpage --keylength ec-256 [Wed 30 Dec 2022 15:22:51 AM EST] Using CA: https://acme-v02.api.letsencrypt.org/directory [Wed 30 Dec 2022 15:22:51 AM EST] Creating domain key [Wed 30 Dec 2022 15:22:51 AM EST] The domain key is here: /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.key [Wed 30 Dec 2022 15:22:51 AM EST] Single domain=\u0026#39;二级域名.你的域名.com\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Getting domain auth token for each domain [Wed 30 Dec 2022 15:22:51 AM EST] Getting webroot for domain=\u0026#39;二级域名.你的域名.com\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Verifying: 二级域名.你的域名.com [Wed 30 Dec 2022 15:22:51 AM EST] Pending [Wed 30 Dec 2022 15:22:51 AM EST] Success [Wed 30 Dec 2022 15:22:51 AM EST] Verify finished, start to sign. [Wed 30 Dec 2022 15:22:51 AM EST] Lets finalize the order. [Wed 30 Dec 2022 15:22:51 AM EST] Le_OrderFinalize=\u0026#39;https://acme-v02.api.letsencrypt.org/acme/finalize/490205996/7730242872\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Downloading cert. [Wed 30 Dec 2022 15:22:51 AM EST] Le_LinkCert=\u0026#39;https://acme-v02.api.letsencrypt.org/acme/cert/vsxvk0oldnuobe51ayxz4dms62sk2dwmw9zhuw\u0026#39; [Wed 30 Dec 2022 15:22:51 AM EST] Cert success. -----BEGIN CERTIFICATE----- sxlYqPvWreKgD5b8JyOQX0Yg2MLoRUoDyqVkd31PthIiwzdckoh5eD3JU7ysYBtN cTFK4LGOfjqi8Ks87EVJdK9IaSAu7ZC6h5to0eqpJ5PLhaM3e6yJBbHmYA8w1Smp wAb3tdoHZ9ttUIm9CrSzvDBt6BBT6GqYdDamMyCYBLooMyDEM4CUFsOzCRrEqqvC 2mTTEmhvpojo5rhdTSJxibozyNWTGwoTj0v9pTUeQcGqLIzqi4DowjBHD5guwRid SjAFnm6JT2xUQgWFm58A1gv1OhbH1TRPUUmtE1nFEN7YiSjI4xgxqAXT3CLD2EUb wXlUrO6c75zSsQP4bRMzgOjJUqHtSb6IEqELzt4M7KzL5iCOruCChCo2DZxUwvVX tOoaAyQJzCbTqE6aUqwiKi3gVyoxvDP9mI5JdRYzsDL6GVud7EHPnYeMl9ubLZAK 0vg84mbMP3f6mYM4KRa1cqiyOIcQPT4AzGFYVv4sm049bZQg7sd0Bz9CaFvE7yDA 1y17XlgCDnsjxl66bqI1vkENN9XT5xeFHONqc18b5fZEKSIvdX7iWPFWp1PyMPpG 0pMCP1EymZNFxIMJLgbWqExwLWfPc5Ib3PjBaIqhXPnw6sT2MQSxXwDupq1UJVhV 7E3hQRVlwI4CXi6WLHJMNvNRyyK87gCrLH1bKYsPeRVaz77poWBq49zwBCts6hPY IeF4ltGXyANNIOPEi8vy138fRU4LYh81d8FjOtFfJZogMjwhfNvapqxPMsioPlmX TnZu0n7setrVNUEfTMHWqPpDgk5MPrWLA4LapqaDfEX4pwnQJLMwMi6s94z165c0 iMRSKA1yU5zqv8aNsDfPoY4OkSPWs4MaXgRRSLBsUfZ15DwQXPk76kegHIyxWvwF tYw9HKR5QCMK66fa0z4aJoFVFLK0IIOGEZOanRFUCnkLUDd3QZ3YU8lEcrj7Uxos haiRNICyC6UfsCJ94a8vcNyMosPv3xBLMp19WXgiFYqEFQkntkv1FLRI35fjeJmg 0fmD9VG9bkzGPHihJgQLRlCHasGf6XrdfkSsODAyCUHUHJ0RzqF4YEZMcxDxzuQ2 YO7bFwj7S3mUdVPZ6MPasjxdyBjJgEBMch2uy4AhmudXfEBQBye8W6ZI4ztZjLVV FmP4SIuaNUmMe20TjR8b9NVC96AhxOanWT3mRROsdokpKQGTJvl27EHH8KuAbUOc G6KtPy4wslNZNXWcBy9n63RcWak12r7kAIFn38tZxmlw2WUKoRSMAH64GcDTjRQd Am65hBHzvGrj93wEuVNIebvNIsJOlng3HFjpIxVqKGMCIfWIKGDE3YzK3p4LbGZ6 NZFQWYJLNVf2M9CCJfbEImPYgvctrxl39H6KVYPCw1SAdaj9NneUqmREOQkKoEB0 x6PmNirbMscHhQPSC0JQaqUgaQFgba1ALmzRYAnYhNb0twkTxWbY7DBkAarxqMIp yiLKcBFc5H7dgJCImo7us7aJeftC44uWkPM= -----END CERTIFICATE----- [Wed 30 Dec 2022 15:22:52 AM EST] Your cert is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.cer [Wed 30 Dec 2022 15:22:52 AM EST] Your cert key is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/二级域名.你的域名.com.key [Wed 30 Dec 2022 15:22:52 AM EST] The intermediate CA cert is in /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/ca.cer [Wed 30 Dec 2022 15:22:52 AM EST] And the full chain certs is there: /home/vpsadmin/.acme.sh/二级域名.你的域名.com_ecc/fullchain.cer    6.4 你的进度  至此，Xray所需要的两个基础设施终于全部就位！千呼万唤始出来的Xray马上就要揭开面纱，我们终于要进入最激动人心章节啦！\nPROGRESS⬛⬛⬛⬛⬛⬛⬜⬜ 75%\n "},{"uri":"https://xtls.github.io/en/config/base/inbounds/","title":"Inbounds","tags":[],"description":"Project X 的文档.","content":"入站连接用于接收发来的数据，可用的协议请见inbound 可用协议列表。\nInboundObject  InboundObject 对应配置文件中 inbounds 项的一个子元素。\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1080, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;sniffing\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }, \u0026#34;allocate\u0026#34;: { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 } } ] }  listen: address\n 监听地址，IP 地址或 Unix domain socket，默认值为 \u0026quot;0.0.0.0\u0026quot;，表示接收所有网卡上的连接.\n可以指定一个系统可用的 IP 地址。\n支持填写 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。\n填写 Unix domain socket 时，port 和 allocate 将被忽略，协议目前可选 VLESS、VMess、Trojan，传输方式可选 TCP、WebSocket、HTTP/2。\nport: number | \u0026ldquo;env:variable\u0026rdquo; | string\n 端口。接受的格式如下:\n 整型数值：实际的端口号。 环境变量：以 \u0026quot;env:\u0026quot; 开头，后面是一个环境变量的名称，如 \u0026quot;env:PORT\u0026quot;。Xray 会以字符串形式解析这个环境变量。 字符串：可以是一个数值类型的字符串，如 \u0026quot;1234\u0026quot;；或者一个数值范围，如 \u0026quot;5-10\u0026quot; 表示端口 5 到端口 10，这 6 个端口。  当只有一个端口时，Xray 会在此端口监听入站连接。当指定了一个端口范围时，取决于 allocate 设置。\nprotocol: string\n 连接协议名称，可选的协议类型见inbound 可用协议列表。\nsettings: InboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 InboundConfigurationObject。\nstreamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\n tag: string\n 此入站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n sniffing: SniffingObject\n 流量探测主要作用于在透明代理等用途. 比如一个典型流程如下:\n 如有一个设备上网,去访问abc.com,首先设备通过DNS查询得到abc.com的IP是1.2.3.4,然后设备会向1.2.3.4去发起连接. 如果不设置嗅探,Xray收到的连接请求是1.2.3.4,并不能用于域名规则的路由分流. 当设置了sniffing中的enable为true,Xray处理此连接的流量时,会从流量的数据中,嗅探出域名,即abc.com Xray会把1.2.3.4重置为abc.com.路由就可以根据域名去进行路由的域名规则的分流  因为变成了一个向abc.com请求的连接, 就可以做更多的事情, 除了路由域名规则分流, 还能重新做DNS解析等其他工作.\n当设置了sniffing中的enable为true, 还能嗅探出bittorrent类型的流量, 然后可以在路由中配置\u0026quot;protocol\u0026quot;项来设置规则处理BT流量, 比如服务端用来拦截BT流量, 或客户端固定转发BT流量到某个VPS去等.\nallocate: AllocateObject\n 当设置了多个port时, 端口分配的具体设置\n\nSniffingObject  { \u0026#34;enabled\u0026#34;: true, \u0026#34;destOverride\u0026#34;: [\u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;] }  enabled: true | false\n 是否开启流量探测。 destOverride: [\u0026ldquo;http\u0026rdquo; | \u0026ldquo;tls\u0026rdquo;]\n 当流量为指定类型时，按其中包括的目标地址重置当前连接的目标。\n\nAllocateObject  { \u0026#34;strategy\u0026#34;: \u0026#34;always\u0026#34;, \u0026#34;refresh\u0026#34;: 5, \u0026#34;concurrency\u0026#34;: 3 }  strategy: \u0026ldquo;always\u0026rdquo; | \u0026ldquo;random\u0026rdquo;\n 端口分配策略。\n \u0026quot;always\u0026quot; 表示总是分配所有已指定的端口，port 中指定了多少个端口，Xray 就会监听这些端口。 \u0026quot;random\u0026quot; 表示随机开放端口，每隔 refresh 分钟在 port 范围中随机选取 concurrency 个端口来监听。  refresh: number\n 随机端口刷新间隔，单位为分钟。最小值为 2，建议值为 5。这个属性仅当 strategy 设置为 \u0026quot;random\u0026quot; 时有效。 concurrency: number\n 随机端口数量。最小值为 1，最大值为 port 范围的三分之一。建议值为 3。\n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/","title":"Outbounds 可用协议列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有可用于 Outbounds 的协议及具体配置细节. 协议列表   Blackhole\n Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合 路由（Routing） 一起使用，可以达到禁止访问某些网站的效果。 DNS\n DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。 Freedom\n Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。 HTTP\n HTTP 协议 Socks\n 标准 Socks 协议实现，兼容 Socks 4、Socks 4a 和 Socks 5。 VLESS\n VLESS 是一个无状态的轻量传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 VMess\n VMess 是一个加密传输协议，可以作为 Xray 客户端和服务器之间的桥梁。 Trojan\n Trojan 协议。 Shadowsocks\n Shadowsocks 协议。\n"},{"uri":"https://xtls.github.io/en/config/transports/quic/","title":"QUIC","tags":[],"description":"Project X 的文档.","content":"QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:\n 减少了握手的延迟（1-RTT 或 0-RTT） 多路复用，并且没有 TCP 的阻塞问题 连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。  QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。\n 默认设定:  12 字节的 Connection ID 30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用)    QuicObject  QuicObject 对应传输配置的 quicSettings 项。\nimportant对接的两端的配置必须完全一致，否则连接失败。 QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，Xray 会自行签发一个证书进行 TLS 通讯。\n { \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;header\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; } }  security: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo;\n 加密方式。\n此加密是对 QUIC 数据包的加密，加密后数据包无法被探测。\n默认值为不加密。\nkey: string\n 加密时所用的密钥。\n可以是任意字符串。当 security 不为 \u0026quot;none\u0026quot; 时有效。\nheader: HeaderObject\n 数据包头部伪装设置\n\nHeaderObject  { \u0026#34;type\u0026#34;: \u0026#34;none\u0026#34; }  type: string\n 伪装类型，可选的值有：\n \u0026quot;none\u0026quot;：默认值，不进行伪装，发送的数据是没有特征的数据包。 \u0026quot;srtp\u0026quot;：伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。 \u0026quot;utp\u0026quot;：伪装成 uTP 数据包，会被识别为 BT 下载数据。 \u0026quot;wechat-video\u0026quot;：伪装成微信视频通话的数据包。 \u0026quot;dtls\u0026quot;：伪装成 DTLS 1.2 数据包。 \u0026quot;wireguard\u0026quot;：伪装成 WireGuard 数据包。（并不是真正的 WireGuard 协议）  TIP\n当加密和伪装都不启用时，数据包即为原始的 QUIC 数据包，可以与其它的 QUIC 工具对接。\n为了避免被探测，建议加密或伪装至少开启一项。\n "},{"uri":"https://xtls.github.io/en/config/outbound-protocols/vless/","title":"VLESS","tags":[],"description":"Project X 的文档.","content":" important目前 VLESS 没有自带加密，请用于可靠信道，如 TLS。 目前 VLESS 不支持分享。\n VLESS 是一个无状态的轻量传输协议，它分为入站和出站两部分，可以作为 Xray 客户端和服务器之间的桥梁。\n与 VMess 不同，VLESS 不依赖于系统时间，认证方式同样为 UUID，但不需要 alterId。\nOutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext: [ ServerObject ]\n 一个数组, 表示 VLESS 服务器列表，包含一组指向服务端的配置, 其中每一项是一个服务器配置。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;example.com\u0026#34;, \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  address: address\n 服务端地址，指向服务端，支持域名、IPv4、IPv6。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\nusers: [ UserObject ]\n 数组, 一组服务端认可的用户列表, 其中每一项是一个用户配置\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id: string\n VLESS 的用户 ID，必须是一个合法的 UUID，你可以用 在线工具 生成它。\nencryption: \u0026ldquo;none\u0026rdquo;\n 需要填 \u0026quot;none\u0026quot;，不能留空。\n该要求是为了提醒使用者没有加密，也为了以后出加密方式时，防止使用者填错属性名或填错位置导致裸奔。 若未正确设置 encryption 的值，使用 Xray 或 -test 时会收到错误信息。\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前出站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-origin-udp443：同 xtls-rprx-origin, 但放行了目标为 443 端口的 UDP 流量 xtls-rprx-direct：所有平台皆可使用的典型流控模式 xtls-rprx-direct-udp443：同 xtls-rprx-direct, 但是放行了目标为 443 端口的 UDP 流量 xtls-rprx-splice：Linux 平台下最建议使用的流控模式 xtls-rprx-splice-udp443：同 xtls-rprx-splice, 但是放行了目标为 443 端口的 UDP 流量  注意\n当 flow 被指定时，还需要将该出站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n 关于 xtls-rprx-*-udp443 流控模式\nVLESS 和 Trojan 协议使用 TCP 传输 UDP，即 UDP over TCP，但 XTLS 不会对 UoT 的数据进行处理。所以为了防止上层应用使用 QUIC，启用 XTLS 时客户端会自动拦截 UDP/443 的请求。若不需要拦截，请在客户端填写 xtls-rprx-*-udp443，服务端不变。\n importantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nSplice 模式的的使用限制：\n Linux 环境 入站协议为 Dokodemo door、Socks、HTTP 等纯净的 TCP 连接, 或其它使用了 XTLS 的入站协议 出站协议为 VLESS + XTLS 或 Trojan + XTLS  此外，使用 Splice 时网速显示会滞后，这是特性，不是 bug。\n需要注意的是，使用 mKCP 协议时不会使用 Splice（是的，虽然没有报错，但实际上根本没用到）。\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n\n配置模板  Xray-examples 有完整的 VLESS 配置示例供参考。（但目前不能保证其它协议的配置示例质量）\n 客户端开发指引   VLESS 协议本身还会有不兼容升级，但客户端配置文件参数基本上是只增不减的。所以如果你开发了用 core 的客户端，现在就可以适配。 iOS 客户端的协议实现则需紧跟升级。 视觉标准：UI 标识请统一用 VLESS，而不是 VLess / Vless / vless，配置文件不受影响，代码内则顺其自然。 encryption 应做成输入框而不是选择框，新配置的默认值应为 none，若用户置空则应代填 none。  以下为已支持图形化配置 VLESS 的部分客户端列表，推荐使用：（按实现时间先后顺序排列）\n 新型协议回落模式解析  In progress\n VLESS 分享链接标准  In progress\n"},{"uri":"https://xtls.github.io/en/config/inbound-protocols/vmess/","title":"VMess","tags":[],"description":"Project X 的文档.","content":"VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; } ], \u0026#34;default\u0026#34;: { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }, \u0026#34;detour\u0026#34;: { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }, \u0026#34;disableInsecureEncryption\u0026#34;: false }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户ClientObject。\n当此配置用作动态端口时，Xray 会自动创建用户。\ndetour: DetourObject\n 指示对应的出站协议使用另一个服务器。\ndefault: DefaultObject\n 可选，clients 的默认配置。仅在配合detour时有效。\ndisableInsecureEncryption: true | false\n 是否禁止客户端使用不安全的加密方式，如果设置为 true 当客户端指定下列加密方式时，服务器会主动断开连接。\n \u0026quot;none\u0026quot; \u0026quot;aes-128-cfb\u0026quot;  默认值为false。\n\nClientObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 4, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34; }  id: string\n VMess 的用户 ID。必须是一个合法的 UUID。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n email: string\n 用户邮箱地址，用于区分不同用户的流量。\n\nDetourObject  { \u0026#34;to\u0026#34;: \u0026#34;tag_to_detour\u0026#34; }  to: string\n 一个 inbound 的tag, 指定的 inbound 的必须是使用 VMess 协议的 inbound.\n\nDefaultObject  { \u0026#34;level\u0026#34;: 0, \u0026#34;alterId\u0026#34;: 0 }  level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nalterId: number\n 动态端口的默认alterId，默认值为0。\n\nVMess MD5 认证信息 玷污机制  为了进一步对抗可能的探测和封锁，每个 VMess 认证数据的服务端结构都会包含一个一次写入的玷污状态标记，初始状态为无瑕状态，当服务器检测到重放探测时或者因为其他原因入站连接出错以致校验数据不正确时，该连接所对应的请求认证数据会被玷污。\n被玷污的认证数据无法被用于建立连接，当攻击者或客户端使用被玷污的认证数据建立连接时，服务器会输出包含 \u0026ldquo;invalid user\u0026rdquo; \u0026ldquo;ErrTainted\u0026rdquo; 的错误信息，并阻止该连接。\n当服务器没有受到重放攻击时，该机制对正常连接的客户端没有影响。\n如果服务器正在被重放攻击，可能会出现连接不稳定的情况。\nTIP\n拥有服务器 UUID 以及其他连接数据的恶意程序可能根据此机制对服务器发起拒绝服务攻击，受到此类攻击的服务可以通过修改 proxy/vmess/validator.go 文件中 func (v *TimedUserValidator) BurnTaintFuse(userHash []byte) error 函数的 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 1) 语句为 atomic.CompareAndSwapUint32(pair.taintedFuse, 0, 0) 来解除服务器对此类攻击的安全保护机制。使用 VMessAEAD 认证机制的客户端不受到 VMess MD5 认证信息 玷污机制 的影响。\n "},{"uri":"https://xtls.github.io/en/faq/xtls/","title":"XTLS相关问题","tags":[],"description":"Project X 的文档.","content":" Q: XTLS是个啥?好吃吗?XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力\n点此查看详情 XTLS\n Q: TLS和XTLS有啥区别?XTLS会不安全吗?安全性没有区别. 传输的数据都是完全加密的\nTLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.\n性能有区别. XTLS比TLS快的多的多的多.\n启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.\n Q: 听说XTLS的数据是不完全加密的，是这样的吗?此说法错误，XTLS传输的数据是完全加密的，和TLS没有区别。\nXTLS去掉了旧时代翻墙模式中不必要的对加密数据的重复加密。即:\n 如果原始数据是已经经过TLS加密的数据（通常上网，绝大部分数据都是已经TLS加密过的数据了），此时XTLS不再和旧时代工具一样进行无用的重复加密，从而获得卓越性能。 如果原始数据不是经过TLS加密的，而是明文数据，XTLS会进行TLS加密。   因此XTLS数据仍然是完全TLS加密的，并且去掉了毫无意义的不必要的重复加密，而不是所谓的不完全加密。\n同时外部看来流量类型和正常上网具有一致性，更具隐蔽性，是最安全的模式。\n "},{"uri":"https://xtls.github.io/en/faq/","title":"常见问答","tags":[],"description":"Project X 的文档.","content":" 如果您有任何疑问, 不妨先到这里看看是不是有人遇到了同样的问题, 并且已经解决了. 下载和安装中的问题 首先您可以点击查看下载和安装Xray\n如果碰到问题, 可以点击这里下载和安装中的问题\n 配置和运行时的问题 首先您可以点击查看配置和运行Xray\n如果碰到问题, 可以点击这里配置和运行时的问题\n 性能相关的问题 速率, 延迟, CPU占用, 内存占用\u0026hellip;\n这些相关的问题请点击这里性能相关的问题\n 透明代理的问题 如果您使用了透明代理\n遇到问题不妨点击这里透明代理的问题\n  \n回落相关的问题 回落是Xray最强大功能之一, 灵活且强大, 可以玩很多杂技\n如有相关问题可以点击回落相关的问题\n XTLS相关的问题 XTLS 是 Xray独创的新科技, 因此 Xray 的性能一骑绝尘.\n如有相关问题可以点击XTLS相关的问题\n  关于 Xray Xray 的非技术问题\n点击查看Xray 的非技术问题\n  \n如果在这里找不到你要的答案或者觉得答案不够细致, 不妨再去翻一翻大案牍术\n "},{"uri":"https://xtls.github.io/en/documents/level-0/ch07-xray-server/","title":"【第7章】Xray服务器篇","tags":[],"description":"小小白白话文","content":"7.1 博观而约取，厚积而薄发  本文撰写过程中，大佬开玩笑的吐槽到：你这教程，居然连载了6章都还没到Xray，不知道的还以为你是“手把手教你建网站”教程呢。（我竟无法反驳.jpg!）\n其实这样的结构是我多番思考之后的决定，毕竟只有打好基础，才能在后面事半功倍快速反超。我在群里看到许多新人连nano都无法正确使用，也不会用WinSCP，远程手写编辑出来的config.json自然错误百出，连查错也变得举步维艰。\n经过了前6章的准备，各位已经跟我一起翻越了Linux基本操作、VPS远程管理、网页搭建、域名管理、证书申请等等几座大山。是不是回头看看，觉得其实非常简单呢？现在我们有了如此扎实的准备，接下来安装和配置Xray时会有一种【水到渠成】的轻快感觉。\n 后面要做的事情非常简单：\n 安装 配置（如安装TLS证书、config.json） 运行 优化（如更新内核、开启bbr、网站http访问自动跳转https等）   7.2 安装Xray  首先，Xray的官方载体，就是 xray-core 开源项目（基于 MPL 2.0 开源协议）生成的二进制程序。你把这个二进制放在服务器运行，它就是服务器端；你把它下载到本地电脑运行，它就是客户端。主要区别来源于【配置】。\n安装时，直接使用官方安装脚本就很简单直接。它提供了多种安装选项，有兴趣的可以去官方的安装脚本仓库中看看脚本的说明，本文使用的是【非root用户】安装模式。\n写本文时，安装脚本在使用非root账户时有一些小bug，所以我决定正好把这几步分开操作，可以顺便说明一下Linux下的删除命令。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-14 rm 删除命令      将安装脚本下载至本地：\n$ wget https://github.com/XTLS/Xray-install/raw/main/install-release.sh   执行安装命令\n$ sudo bash install-release.sh   使用完成之后可以删除该脚本\n$ rm ~/install-release.sh  注意： 使用 rm 命令删除文件的时候，默认其实就是删除现在所在的文件夹下的文件。但是，我依然写了完整的路径： ~/install-release.sh，这是我使用 rm 时的一个安全习惯、也是我把安装分成几步之后想强调一下的内容。如果你听过一些“程序员从删库到跑路”之类的段子，大概就知道为什么了。\n   完整流程演示如下：\n   7.3 给Xray配置TLS证书  虽然我们前面已经申请好了TLS证书，但是按照 acme.sh的官方说明，申请后的证书不建议直接使用。正确的方法是使用 --install-cert 命令安装给需要的程序。我们现在就来把证书安装给 xray-core 使用。\n  为了规避非root账户的各种潜在的权限困扰，我们在vpsadmin账户下建立一个证书文件夹\n$ mkdir ~/xray_cert   使用acme.sh的--install-cert正确安装（拷贝）证书文件\n$ acme.sh --install-cert -d 二级域名.你的域名.com --ecc \\ --fullchain-file ~/xray_cert/xray.crt \\ --key-file ~/xray_cert/xray.key   xray.key文件默认对其他用户不可读，所以需要赋予其可读性权限\n$ chmod +r ~/xray_cert/xray.key   过程比较简单就不放动图了：\n  acme.sh 会每60天检查一次证书并自动更新临期证书。但据我所知是它并不会自动将新证书安装给 xray-core，所以我们需要新增一个系统的自动周期任务来完成这一步。\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-15 crontab -e 编辑当前用户的定时任务      建立一个脚本文件（xray-cert-renew.sh）\n$ nano ~/xray_cert/xray-cert-renew.sh   把下面的内容复制进去，记得替换你的真实域名，然后保存退出\n#!/bin/bash  /home/vpsadmin/.acme.sh/acme.sh --install-cert -d a-name.yourdomain.com --ecc --fullchain-file /home/vpsadmin/xray_cert/xray.crt --key-file /home/vpsadmin/xray_cert/xray.key echo \u0026#34;Xray Certificates Renewed\u0026#34; chmod +r /home/vpsadmin/xray_cert/xray.key echo \u0026#34;Read Permission Granted for Private Key\u0026#34; sudo systemctl restart xray echo \u0026#34;Xray Restarted\u0026#34;  注意： 经大家提醒，acme.sh 有一个 reloadcmd 命令，可以在证书更新时自动执行特定命令，那么就可以指定自动给 Xray 安装证书，但因为 crontab 是 Linux 系统中一个非常有用、非常常用的功能，所以本文保留 crontab 的方式来更新 Xray 证书。（对 reloadcmd 感兴趣的同学可以查看 acme.sh 的官方文档）\n另外，录制动图时，脚本中没有加入重启 Xray 的命令，是因为 Xray 计划支持【证书热更新】功能，即 Xray 会自动识别证书更新并重载证书、无需手动重启。待功能加入后，我将适当修改 config.json 开启此设置，并删除脚本中的重启命令。\n   给这个文件增加【可执行】权限\n$ chmod +x ~/xray_cert/xray-cert-renew.sh   运行 crontab -e，添加一个自动任务【每月自动运行一次xray-cert-renew.sh】 (注意不要加sudo，因为我们增加的是vpsadmin账户的自动任务。初次运行时会让你选择编辑器，当然是选择熟悉的nano啦！)\n$ crontab -e   把下面的内容增加在文件最后，保存退出即可。\n# 1:00am, 1st day each month, run `xray-cert-renew.sh` 0 1 1 * * bash /home/vpsadmin/xray_cert/xray-cert-renew.sh   完整流程演示如下：\n     7.4 配置Xray  首先，各种配置都可以参考官方VLESS配置示例。本文会基于官方示例，配置一个最精简的方式：【单 VLESS 协议入站 + 80 端口回落】，满足大多数场景的最大速度及必要安全。\n  生成一个合法的 UUID 并保存备用（UUID可以简单粗暴的理解为像指纹一样几乎不会重复的ID）\n$ xray uuid   建立日志文件及文件夹备用\n  小小白白Linux基础命令：\n   编号 命令名称 命令说明     cmd-16 touch 建立空白文件      在vpsadmin的文件夹内建立一个【日志专用文件夹】\n$ mkdir ~/xray_log   生成所需的两个日志文件（访问日志、错误日志）\n$ touch ~/xray_log/access.log \u0026amp;\u0026amp; touch ~/xray_log/error.log  注意： 这个位置不是Xray标准的日志文件位置，放在这里是避免权限问题对新人的操作带来困扰。当你熟悉之后，建议回归默认位置： /var/log/xray/access.log 和 /var/log/xray/error.log 。\n   因为Xray默认是nobody用户使用，所以我们需要让其他用户也有“写”的权限（*.log 就是所有文件后缀是log的文件，此时CLI界面的效率优势就逐渐出现了）\n$ chmod a+w ~/xray_log/*.log     使用nano创建Xray的配置文件\n$ sudo nano /usr/local/etc/xray/config.json   将下面的文件全部复制进去，并将之前生成的UUID填入第61行 \u0026quot;id\u0026quot;: \u0026quot;\u0026quot;, 之中。（填好之后的样子是 \u0026quot;id\u0026quot;: \u0026quot;uuiduuid-uuid-uuid-uuid-uuiduuiduuid\u0026quot;），本文的这个配置文件中增加了我的各种啰嗦注解，以方便你理解每一个配置模块的功能是什么。\n// REFERENCE: // https://github.com/XTLS/Xray-examples // https://xtls.github.io/config/ // 常用的config文件，不论服务器端还是客户端，都有5个部分。外加小小白解读： // ┌─ 1_log 日志设置 - 日志写什么，写哪里（出错时有据可查） // ├─ 2_dns DNS-设置 - DNS怎么查（防DNS污染、防偷窥、避免国内外站匹配到国外服务器等） // ├─ 3_routing 分流设置 - 流量怎么分类处理（是否过滤广告、是否国内外分流） // ├─ 4_inbounds 入站设置 - 什么流量可以流入Xray // └─ 5_outbounds 出站设置 - 流出Xray的流量往哪里去 { // 1_日志设置 \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34;, // 内容从少到多: \u0026#34;none\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;warning\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;debug\u0026#34; \u0026#34;access\u0026#34;: \u0026#34;/home/vpsadmin/xray_log/access.log\u0026#34;, // 访问记录 \u0026#34;error\u0026#34;: \u0026#34;/home/vpsadmin/xray_log/error.log\u0026#34; // 错误记录 }, // 2_DNS设置 \u0026#34;dns\u0026#34;: { \u0026#34;servers\u0026#34;: [ \u0026#34;https+local://1.1.1.1/dns-query\u0026#34;, // 首选1.1.1.1的DoH查询，牺牲速度但可防止ISP偷窥 \u0026#34;localhost\u0026#34; ] }, // 3_分流设置 \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 3.1 防止服务器本地流转问题：如内网被攻击或滥用、错误的本地回环等 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:private\u0026#34; // 分流条件：geoip文件内，名为\u0026#34;private\u0026#34;的规则（本地） ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; // 分流策略：交给出站\u0026#34;block\u0026#34;处理（黑洞屏蔽） }, // 3.2 屏蔽广告 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; // 分流条件：geosite文件内，名为\u0026#34;category-ads-all\u0026#34;的规则（各种广告域名） ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; // 分流策略：交给出站\u0026#34;block\u0026#34;处理（黑洞屏蔽） } ] }, // 4_入站设置 // 4.1 这里只写了一个最简单的vless+xtls的入站，因为这是Xray最强大的模式。如有其他需要，请根据模版自行添加。 \u0026#34;inbounds\u0026#34;: [ { \u0026#34;port\u0026#34;: 443, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;\u0026#34;, // 填写你的 UUID \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;email\u0026#34;: \u0026#34;vpsadmin@yourdomain.com\u0026#34; } ], \u0026#34;decryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 // 默认回落到防探测的代理 } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;allowInsecure\u0026#34;: false, // 正常使用应确保关闭 \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34;, // TLS最低版本设置 \u0026#34;alpn\u0026#34;: [ \u0026#34;http/1.1\u0026#34; ], \u0026#34;certificates\u0026#34;: [ { \u0026#34;certificateFile\u0026#34;: \u0026#34;/home/vpsadmin/xray_cert/xray.crt\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/home/vpsadmin/xray_cert/xray.key\u0026#34; } ] } } } ], // 5_出站设置 \u0026#34;outbounds\u0026#34;: [ // 5.1 第一个出站是默认规则，freedom就是对外直连（vps已经是外网，所以直连） { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; }, // 5.2 屏蔽规则，blackhole协议就是把流量导入到黑洞里（屏蔽） { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34; } ] }   完整流程演示如下：\n   7.5 启动Xray服务！！（并查看服务状态）  如果你是跟随本文一步步设置过来，其实就已经避开了最常见日志文件权限不足、证书文件权限不足 这两个大坑。那么现在运行Xray自然应该无比顺利。\n  输入下面的命令，享受启动Xray的历史性时刻吧！！！\n$ sudo systemctl start xray   仅仅start我们并不能确定是否成功的开启了Xray的服务，要确定它的状态，就要用到下面的命令。\n$ sudo systemctl status xray 看到那个绿色的、令人愉悦的 active (running) 了吗？它就是说 Xray 已经在正确的运行了\n  完整流程演示如下：\n   7.6 回顾 systemd 进行基本的服务管理  到现在为止，我们已经使用过了systemctl相关的start, status, reload 等命令，这些都是基于systmed管理模块对Linux系统中各种服务进行管理的通用命令。现在正好熟悉一下相关的其他几个命令。\n  若你需要暂时关闭 Xray 的服务，那就用stop命令\n$ sudo systemctl stop xray   若你需要重启Xray的服务，那就用restart命令\n$ sudo systemctl restart xray   若你需要禁用Xray的服务（电脑重启后禁止Xray自动运行），那就用disable命令\n$ sudo systemctl disable xray   若你需要启用Xray的服务（电脑重启后确保Xray自动运行），那就用enable命令\n$ sudo systemctl enable xray    7.7 服务器优化之一：开启BBR    传说中的BBR\n我相信，你在搜索各种科学上网技术的时候，肯定不止一次的听过bbr这个东西，在各种博客添油加醋之下，让人觉得它神乎其神。更有bbrplus, bbr2, 魔改bbr 等一大堆衍生品。仿佛神油一般，用了就能野鸡线路变专线。\n那么，这东西究竟是什么？它有没有用？又该用哪一个版本呢？\n  实际的BBR\nBBR = Bottleneck Bandwidth and Round-trip propagation time，是一种TCP的拥塞控制算法。简单粗暴的理解就是数据流量的交通管理：当公路不再塞车的时候，每辆车自然就能保持较快的车速了。\n那么它有没有用呢？一般而言，有BBR 和 没有BBR 会有可以感知的差别（速度、稳定性、延迟方面都会有一些改善），所以 【非常建议开启 BBR】。\n但开启之后，BBR 在 4.x 和 5.x 之间的差异往往比较微妙、见仁见智，造成体验差别的决定性因素仍然是线路质量。所以 【不必纠结版本、不必盲目追新、跟随你的发行版更新内核即可】\n  bbrplus, bbr2, 魔改bbr 和其他各种听起来就酷炫的版本是不是更好？\n一句话：不是！不要用这些！这些都为了吸引眼球乱起的名字！\nBBR 的更新和发布，都是跟随Linux的内核（Kernel）进行的。换言之，只要你用的是比较新的内核，就自然会使用到新版BBR。\n而这些名字看起来很酷炫的东西，说白了就是仍未正式发布的、尚在测试阶段的内核及其对应的BBR版本。这些脚本也仅仅就是通过下载预览版的内核（甚至第三方魔改内核）来率先开启而已。\n内核的稳定是一台服务器的稳定的基石。【BBR测试版带来的细微性能差异绝对不值得更换不稳定的内核。】 请选择你所在的Linux发行版所支持的最新内核，这样可以最大限度的保持服务器的长期稳定和兼容。\n注意： 所谓魔改bbr的【领先】是有非常强的时效性的。比如很多 bbrplus 脚本，因为几年来都没有更新，到现在还会把你的内核换成 4.19，要知道现在稳定如 Debian 已经是 5.9 的时代了，那么这个脚本放在2018年1月也许领先了一点，到2018年10月4.19正发布时就已经失去了意义，放在现在甚至可以说是完完全全的【降级】和【劣化】\n   fq, fq_codel, fq_pie, cake和其他算法哪个好？\n一句话：看不懂的话，请保持fq，足够、且不会劣化你的线路\n  锐速、Finalspeed、LotServer和其他“加速工具”\n一句话：不要用这些！把他们丢进历史的垃圾桶吧！\n它能解决的也只有丢包率的问题。不太准确的比喻，就是本来你用一辆车送你的货，有时候车半路就坏了（丢包），用了这些以后，你直接派出3份一样的货，让三辆车同时送，只要有一辆没坏就能送到。马路上都是你的车，自然就能把别人挤下去。但可想而知，你挤别人的时候，别人也会来挤你，而整个机房的出口道路一共就那么宽，最终势必就变成集体大堵车了。\n说明： 它们的原理不是算法优化、不是提速、大多数是简单粗暴的多倍发包。对于【丢包率非常高】的差线路可能有一点作用，但【对丢包率低的好线路没有任何优化作用，反而会成倍的消耗你的流量】，进而造成服务器和你的邻居不必要的压力。\n如果你的线路真的丢包率奇高，真正靠谱的解决方案是【换线路】。\n   啰嗦了这么多，就是因为围绕 BBR 忽悠小白的错误概念和坑人脚本实在是太多了。我希望你们现在对 BBR 有了相对清晰的理解。接下来，我们就动手安装最新的Debian内核并开启BBR 吧！（真的很简单）\n  给 Debian 10 添加官方 backports 源，获取更新的软件库\n$ sudo nano /etc/apt/sources.list  说明： 本文以 Debian 10 为例，所以使用 /etc/apt/sources.list 仍无问题，但如果你并不是根据本文从头开始，或者使用了其他Linux发行版，那么建议你建立 /etc/apt/sources.list.d/ 文件夹，并在这个文件夹内建立自己的配置文件，形如 /etc/apt/sources.list.d/vpsadmin.list，以此保证兼容性，也可避免默认文件在不可预见的情况下被覆盖而导致配置丢失。\n   然后把下面这一条加在最后，并保存退出。\ndeb http://deb.debian.org/debian buster-backports main   刷新软件库并查询 Debian 官方的最新版内核并安装。请务必安装你的VPS对应的版本（本文以比较常见的【amd64】为例）。\n$ sudo apt update \u0026amp;\u0026amp; sudo apt -t buster-backports install linux-image-amd64  注意： 如果你的VPS支持，可以尝试【云服务器专用内核】linux-image-cloud-amd64，优点就是精简、资源占用低，缺点嘛是有同学反馈不支持的系统强行安装会导致无法开机（Kernel无法识别）。\n为了避免无法识别的悲剧，请确保：\n 尝试前做一个系统快照，或者 你有 vnc 可以救场（并且你知道怎么用）     修改 kernel 参数配置文件 sysctl.conf 并指定开启 BBR\n$ sudo nano /etc/sysctl.conf  说明： 本文以 Debian 10 为例，所以使用 /etc/sysctl.conf 仍无问题，但如果你并不是跟着本文从头开始，或者使用了其他Linux发行版，那么建议你建立 /etc/sysctl.d/ 文件夹，并在这个文件夹内建立自己的配置文件，形如 /etc/sysctl.d/vpsadmin.conf，以此保证兼容性，因为部分发行版在 systemd 207 版本之后便不再从 /etc/sysctl.conf 读取参数。使用自定义配置文件也可避免默认文件在不可预见的情况下被覆盖而导致配置丢失。\n   把下面的内容添加进去\nnet.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr   重启VPS、使内核更新和BBR设置都生效\n$ sudo reboot   完整流程演示如下：\n啰嗦君： 因为我做展示的VPS支持云服务器专用内核，所以动图中我用了 linux-image-cloud-amd64 。如果你不确定你的VPS是否支持，那请务必按照第3步的命令，使用常规内核 linux-image-amd64。\n   确认BBR开启\n如果你想确认 BBR 是否正确开启，可以使用下面的命令：\n$ lsmod | grep bbr 此时应该返回这样的结果：\ntcp_bbr 如果你想确认 fq 算法是否正确开启，可以使用下面的命令：\n$ lsmod | grep fq 此时应该返回这样的结果：\nsch_fq      7.8 服务器优化之二：开启HTTP自动跳转HTTPS    之前我们已经搭建了 80 端口的 http 网页，并以此申请了TLS证书。\n但如果你尝试过用浏览器访问我们的这个界面，就会发现 http 访问并不会像大多数网站一样自动升级为 https 访问。换言之，我们现在的设置下，http(80) 和 https(443)之间完全是独立的。如果要解决这个问题，就需要做一些修改。\n  编辑Nginx的配置文件\n$ sudo nano /etc/nginx/nginx.conf   在我们设置过的80端口Server中加入下面的语句，并保存退出（可同时删除root和index两行）\nreturn 301 https://$http_host$request_uri;   在与 80 端口同级的位置增加一个本地端口监听来提供网页展示。本文以 8080 端口做演示。（可以是任意端口）\nserver { listen 127.0.0.1:8080; root /home/vpsadmin/www/webpage; index index.html; add_header Strict-Transport-Security \u0026#34;max-age=63072000\u0026#34; always; }   重启 Nginx 服务\n$ sudo systemctl restart nginx   修改Xray的回落设置，将回落从 80 端口改为 8080 端口。（找到 \u0026quot;dest\u0026quot;: 80, 并改成 \u0026quot;dest\u0026quot;: 8080）\n$ sudo nano /usr/local/etc/xray/config.json   重启 Xray 服务，即完成了设置\n$ sudo systemctl restart xray   完整流程演示如下：\n  当你输入 http://a-name.yourdomain.com的时候，它应该已经会自动跳转https了\n   7.9 你的进度  恭喜！！到这一步，你已经拥有了可以正常科学上网的服务器、同时也有了可以防止主动探测攻击的伪装网站。接下来，只要给你的客户端装上合适的软件，就可以享受顺畅的网络了！\nPROGRESS⬛⬛⬛⬛⬛⬛⬛⬜ 87.5%\n   7.10 重要勘误    初版中Xray配置文件config.json文件夹位置错误。若你已经根据之前的位置进行了操作，Xray会无法正确启动。故勘误说明于此，请自查，造成不便十分抱歉！\n 正确位置：/usr/local/etc/xray/config.json 错误位置：/usr/local/etc/config.json  受影响章节：\n 7.4 配置Xray - 3. 使用nano创建Xray的配置文件 7.8 服务器优化之二 - 6. 修改Xray的回落设置    初版中修改Nginx配置文件nginx.conf时内容错误（网页文件夹位置错误），若你已经根据之前的位置进行了操作，Nginx会无法找到正确的网站。请自查，造成不便十分抱歉！\n 正确文件夹位置：root /home/vpsadmin/www/webpage; 错误文件夹位置：root /var/www/website/html  受影响章节：\n 7.8 服务器优化之二 - 4. 在与 80 端口同级的位置增加一个本地端口监听来提供网页展示    "},{"uri":"https://xtls.github.io/en/config/base/outbounds/","title":"Outbounds","tags":[],"description":"Project X 的文档.","content":"出站连接用于发送数据，可用的协议请见outbound 可用协议列表。\nOutboundObject  OutboundObject 对应配置文件中 outbounds 项的一个子元素。 TIP\n列表中的第一个元素作为主outbound。当路由匹配不存在或没有匹配成功时，流量由主outbound发出。\n { \u0026#34;outbounds\u0026#34;: [ { \u0026#34;sendThrough\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;协议名称\u0026#34;, \u0026#34;settings\u0026#34;: {}, \u0026#34;tag\u0026#34;: \u0026#34;标识\u0026#34;, \u0026#34;streamSettings\u0026#34;: {}, \u0026#34;proxySettings\u0026#34;: { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }, \u0026#34;mux\u0026#34;: {} } ] }  sendThrough: address\n 用于发送数据的 IP 地址，当主机有多个 IP 地址时有效，默认值为 \u0026quot;0.0.0.0\u0026quot;。 protocol: string\n 连接协议名称，可选的协议类型见outbound 可用协议列表。 settings: OutboundConfigurationObject\n 具体的配置内容，视协议不同而不同。详见每个协议中的 OutboundConfigurationObject。 tag: string\n 此出站连接的标识，用于在其它的配置中定位此连接。\nimportant当其不为空时，其值必须在所有 tag 中 唯一。\n streamSettings: StreamSettingsObject\n 底层传输方式（transport）是当前 Xray 节点和其它节点对接的方式\nproxySettings: ProxySettingsObject\n 出站代理配置。当出站代理生效时，此outbound的 streamSettings 将不起作用。\nmux: MuxObject\n Mux 相关的具体配置。\n\nProxySettingsObject  { \u0026#34;tag\u0026#34;: \u0026#34;another-outbound-tag\u0026#34; }  tag: string\n 当指定另一个outbound的标识时，此outbound发出的数据，将被转发至所指定的outbound发出。\n\nMuxObject  Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据。实现细节详见 Mux.Cool。Mux 是为了减少 TCP 的握手延迟而设计，而非提高连接的吞吐量。使用 Mux 看视频、下载或者测速通常都有反效果。Mux 只需要在客户端启用，服务器端自动适配。\nMuxObject 对应 OutboundObject 中的 mux 项。\n{ \u0026#34;enabled\u0026#34;: false, \u0026#34;concurrency\u0026#34;: 8 }  enabled: true | false\n 是否启用 Mux 转发请求，默认值 false。 concurrency: number\n 最大并发连接数。最小值 1，最大值 1024，默认值 8。\n这个数值表示了一个 TCP 连接上最多承载的 Mux 连接数量。比如设置 concurrency=8 时，当客户端发出了 8 个 TCP 请求，Xray 只会发出一条实际的 TCP 连接，客户端的 8 个请求全部由这个 TCP 连接传输。\nTIP\n填负数时，如 -1，不加载 mux 模块。\n "},{"uri":"https://xtls.github.io/en/config/inbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n InboundConfigurationObject  { \u0026#34;clients\u0026#34;: [ { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; } ], \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ] }  clients: [ ClientObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户 ClientObject。\nfallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置（可选）。\nTIP\nXray 的 Trojan 有完整的 fallbacks 支持，配置方式完全一致。 触发回落的条件也与VLESS类似：首包长度 \u0026lt; 58 或第 57 个字节不为 \u0026lsquo;\\r\u0026rsquo;（因为 Trojan 没有协议版本）或身份认证失败。\n \nClientObject  { \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34; }  password: string\n 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nimportant如果存在多个 ClientObject, 请注意 email 不可以重复。\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nuserLevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前入站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式，此时客户端仅可选择 xtls-rprx-origin 和 xtls-rprx-origin-udp443 这两种流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-direct：推荐，所有平台皆可使用的典型流控方式，此时客户端可选择任何流控模式  注意\n当 flow 被指定时，还需要将该入站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n \n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/vmess/","title":"VMess","tags":[],"description":"Project X 的文档.","content":"VMess VMess 是一个加密传输协议，通常作为 Xray 客户端和服务器之间的桥梁。\nimportantVMess 依赖于系统时间，请确保使用 Xray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装ntp服务来自动同步系统时间。\n OutboundConfigurationObject  { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }  vnext：[ ServerObject ]\n 一个数组，包含一组的服务端配置.\n其中每一项是一个服务端配置ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 37192, \u0026#34;users\u0026#34;: [] }  address: address\n 服务端地址，支持 IP 地址或者域名。\nport: number\n 服务端监听的端口号, 必填。\nusers: [ UserObject ]\n 一个数组，代表一组服务端认可的用户.\n其中每一项是一个用户UserObject。\n\nUserObject  { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34;, \u0026#34;alterId\u0026#34;: 0, \u0026#34;security\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;level\u0026#34;: 0 }  id：string\n VMess 用户的主 ID。必须是一个合法的 UUID。\nalterId：number\n 为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 0 代表启用 VMessAEAD。\n最大值 65535。这个值不能超过服务器端所指定的值。\n不指定的话，默认值是 0。\nTIP\n客户端 AlterID 设置为 0 代表启用 VMessAEAD ；服务端为自动适配，可同时兼容启用和未开启 VMessAEAD 的客户端。\n客户端可通过设置环境变量 Xray_VMESS_AEAD_DISABLED=true 强行禁用 VMessAEAD\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nsecurity: \u0026ldquo;aes-128-gcm\u0026rdquo; | \u0026ldquo;chacha20-poly1305\u0026rdquo; | \u0026ldquo;auto\u0026rdquo; | \u0026ldquo;none\u0026rdquo;\n 加密方式，客户端将使用配置的加密方式发送数据，服务器端自动识别，无需配置。\n \u0026quot;aes-128-gcm\u0026quot;：推荐在 PC 上使用 \u0026quot;chacha20-poly1305\u0026quot;：推荐在手机端使用 \u0026quot;auto\u0026quot;：默认值，自动选择（运行框架为 AMD64、ARM64 或 s390x 时为 aes-128-gcm 加密方式，其他情况则为 Chacha20-Poly1305 加密方式） \u0026quot;none\u0026quot;：不加密  TIP\n推荐使用\u0026quot;auto\u0026quot;加密方式，这样可以永久保证安全性和兼容性。\n "},{"uri":"https://xtls.github.io/en/config/transports/","title":"传输方式列表","tags":[],"description":"Project X 的文档.","content":" 这个章节包含了目前所有的传输方式及相关的具体配置. 传输方式列表 tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\n"},{"uri":"https://xtls.github.io/en/caseslip/","title":"大案牍术","tags":[],"description":"Project X 的文档.","content":" 大案牍术记载了 Xray 历史上经过大量研究而破解的迷案, 虽然有些卷宗也许已经迷失在时空里… \n卷宗一览  结案 《大案牍术 卷宗一》\u0026ndash; \u0026ndash; 流量统计功能会使裸协议的 ReadV 和 WriteV 同时失效\n相关卷宗开启各种姿势的统计对各种协议组合性能影响的测试\n  经办@rprx @Arthur Morgan\n 结案 《大案牍术 卷宗三》 \u0026ndash; \u0026ndash; 我们是如何破解Splice性能下降甚至低于Direct之谜的\n相关卷宗HARDWARE NAT\n 经办@rprx @Arthur Morgan\n \n未结案 《大案牍术 卷宗五》 \u0026ndash; \u0026ndash; DS性能之谜?\n相关卷宗DS性能测试\n 经办@rprx @Arthur Morgan\n \n结案 《大案牍术 卷宗六》 \u0026ndash; \u0026ndash; 启动内存之优化优化再优化\n相关卷宗多核服务端单核心负载问题 CPUNum测试\n -- 经办@rprx @AT!Mi @SekiBetu\n \n结案 《大案牍术 卷宗七》 \u0026ndash; \u0026ndash; 一核有难, 多核围观?\n相关卷宗多核服务端单核心负载问题 CPUNum测试\n 经办@rprx @Arthur Morgan @ldmlz\n \n结案 《大案牍术 卷宗八》 \u0026ndash; \u0026ndash; 彩虹六号! 消失的UDP! \n经办@rprx @GleenJi\n \n"},{"uri":"https://xtls.github.io/en/documents/level-0/ch08-xray-clients/","title":"【第8章】Xray客户端篇","tags":[],"description":"小小白白话文","content":"8.1 Xray的工作原理简述  要正确的配置和使用Xray，就需要正确的理解其工作原理，对于新人，可以先看看下面简化的示意图（省略了许多复杂的设置）：\n这其中的关键点是：\n  APP要主动或借助转发工具，将数据【流入(inbounds)】Xray 客户端\n  流量进入客户端后，会被【客户端路由(routing)】按规则处理后，向不同方向【流出(outbounds)】Xray 客户端。比如：\n 国内流量直连（direct） 国外流量转发VPS（proxy） 广告流量屏蔽（block）    向VPS转发的国外流量，会跨过防火墙，【流入(inbounds)】 Xray 服务器端\n  流量进入服务器端后，与客户端一样，会被【服务器端路由(routing)】按规则处理后，向不同方向【流出(outbounds)】：\n 因为已经在防火墙之外，所以流量默认直连，你就可以访问到不存在网站们了（direct） 如果需要在不同的VPS之间做链式转发，就可以继续配置转发规则（proxy） 你可以在服务器端继续禁用各种你想禁用的流量，如广告、BT下载等（block）    注意： 请务必记得，Xray 的路由配置非常灵活，上面的说明只是无限可能性中的一种。\n借助 geosite.dat 和 geoip.dat 这两个文件，可以很灵活的从【域名】和【IP】这两个角度、不留死角的控制流量流出的方向。这比曾经单一笼统的 GFWList 强大很多很多，可以做到非常细致的微调：比如可以指定Apple域名直连或转发、指定亚马逊域名代理或转发，百度的域名屏蔽等等。。。）\n  8.2 客户端与服务器端正确连接  现在你已经理解了 Xray 的工作原理，那么接下来的配置，其实就是【告诉你的客户端如何连接VPS服务器】。这和你已经很熟悉的、告诉PuTTY如何远程连接服务器是一样的。只不过Xray连接时的要素不止是【IP地址】+【端口】+【用户名】+【密码】这四要素了。\n实际上，Xray的连接要素是由不同的协议决定的。本文在第7章的配置文件 config.json 里，我们使用 Xray 下独特而强大的 VLESS 协议 + XTLS 流控。所以看看那个配置文件的内容就能知道，这个协议组合的连接要素有：\n 服务器【地址】: a-name.yourdomain.com 服务器【端口】: 443 连接的【协议】: vless 连接的【流控】: xtls-rprx-direct (direct模式适合全平台，若是Linux/安卓用户，可改成 xtls-rprx-splice 性能全开) 连接的【验证】: uuiduuid-uuid-uuid-uuiduuiduuid 连接的【安全】: \u0026quot;allowInsecure\u0026quot;: false  鉴于新人一般都会使用手机APP或者电脑的GUI客户端，我就把常用的客户端罗列在下面。每个客户端都有自己独特的配置界面，逐一截图展示并不现实，所以请你务必仔细阅读这些客户端的说明、然后把上述要素填入合适的地方即可。\n  v2rayN - 适用于Windows平台\n 请从它的GitHub仓库Release页面获取最新版 请根据该客户端的说明进行设置    v2rayNG - 适用于Android平台\n 请从它的GitHub仓库Release页面获取最新版 请根据该客户端的说明进行设置    Shadowrocket - 适用于iOS, 基于苹果M芯片的macOS\n 你需要注册一个【非中国区】的iCloud账户 你需要通过 App Store 搜索并购买 请根据该客户端的说明进行设置    Qv2ray - 跨平台图形界面，适用于Linux, Windows, macOS\n 请从它的GitHub仓库Release页面获取最新版（还可以从它的GitHub自动构建仓库寻找更新的版本） 请从它的项目主页学习文档 请根据该客户端的说明进行设置    到这一步，你的全套配置就已经可以正常使用啦！\n 8.3 附加题 1：在PC端手工配置 xray-core  虽然到上面一步已经可以结束了，但是如果你是个好奇心强、记忆力好的的同学，一定会想起来我在上一章说过，你把xray-core 的二进制文件“放在服务器运行，它就是服务器端；你把它下载到本地电脑运行，它就是客户端。” 那究竟要怎样直接使用 xray-core 做客户端呢？\n为了回答这个问题，我加入了附加题章节，有一点点超纲，有一点点麻烦，但费这个笔墨是因为这个方式有它的优势：\n  第一时间获得最新版而无需等待APP升级适配\n  灵活自由的路由配置能力（当然GUI客户端中Qv2ray的高级路由编辑器非常强大，也可以完整实现xray-core的路由配置功能）\n  节约系统资源 （GUI界面一定会有资源消耗，消耗的多少则取决于客户端的实现）\n  它的劣势应该就是【需要手写配置文件】有点麻烦了。但其实，你想想，服务器上你已经成功的写过一次了，现在又有什么区别呢？接下来，还是老样子，我们分解一下步骤：\n  首先请从Xray官方的 GitHub仓库Release页面 获取对应平台的版本，并解压缩到合适的文件夹\n  在合适的文件夹建立空白配置文件：config.json （自己常用平台下新建文件大家肯定都会，这就真不用啰嗦了）\n  至于什么是“合适的文件夹”？这就取决于具体的平台了~\n  填写客户端配置\n 我就以 8.1 原理说明里展示的基本三类分流（国内流量直连、国际流量转发VPS、广告流量屏蔽），结合 8.2 的连接要素，写成一个配置文件 请将 uuid 替换成与你服务器一致的 uuid 请将 address 替换成你的真实域名 请将 serverName 替换成你的真实域名 各个配置模块的说明我都已经（很啰嗦的）放在对应的配置点上了  // REFERENCE: // https://github.com/XTLS/Xray-examples // https://xtls.github.io/config/ // 常用的config文件，不论服务器端还是客户端，都有5个部分。外加小小白解读： // ┌─ 1_log 日志设置 - 日志写什么，写哪里（出错时有据可查） // ├─ 2_dns DNS-设置 - DNS怎么查（防DNS污染、防偷窥、避免国内外站匹配到国外服务器等） // ├─ 3_routing 分流设置 - 流量怎么分类处理（是否过滤广告、是否国内外分流） // ├─ 4_inbounds 入站设置 - 什么流量可以流入Xray // └─ 5_outbounds 出站设置 - 流出Xray的流量往哪里去 { // 1_日志设置 // 注意，本例中我默认注释掉了日志文件，因为windows, macOS, Linux 需要写不同的路径，请自行配置 \u0026#34;log\u0026#34;: { // \u0026#34;access\u0026#34;: \u0026#34;/home/local/xray_log/access.log\u0026#34;, // 访问记录 // \u0026#34;error\u0026#34;: \u0026#34;/home/local/xray_log/error.log\u0026#34; // 错误记录 \u0026#34;loglevel\u0026#34;: \u0026#34;warning\u0026#34; // 内容从少到多: \u0026#34;none\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;warning\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;debug\u0026#34; }, // 2_DNS设置 \u0026#34;dns\u0026#34;: { \u0026#34;servers\u0026#34;: [ // 2.1 国外域名使用国外DNS查询 { \u0026#34;address\u0026#34;: \u0026#34;1.1.1.1\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ] }, // 2.2 国内域名使用国内DNS查询，并期待返回国内的IP，若不是国内IP则舍弃，用下一个查询 { \u0026#34;address\u0026#34;: \u0026#34;223.5.5.5\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;expectIPs\u0026#34;: [ \u0026#34;geoip:cn\u0026#34; ] }, // 2.3 作为2.2的备份，对国内网站进行二次查询 { \u0026#34;address\u0026#34;: \u0026#34;114.114.114.114\u0026#34;, \u0026#34;domains\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ] }, // 2.4 最后的备份，上面全部失败时，用本机DNS查询 \u0026#34;localhost\u0026#34; ] }, // 3_分流设置 // 所谓分流，就是将符合否个条件的流量，用指定`tag`的出站协议去处理（对应配置的5.x内容） \u0026#34;routing\u0026#34;: { \u0026#34;domainStrategy\u0026#34;: \u0026#34;AsIs\u0026#34;, \u0026#34;rules\u0026#34;: [ // 3.1 广告域名屏蔽 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:category-ads-all\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;block\u0026#34; }, // 3.2 国内域名直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; }, // 3.3 国内IP直连 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;ip\u0026#34;: [ \u0026#34;geoip:cn\u0026#34;, \u0026#34;geoip:private\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;direct\u0026#34; }, // 3.4 国外域名代理 { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;domain\u0026#34;: [ \u0026#34;geosite:geolocation-!cn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;proxy\u0026#34; } // 3.5 默认规则 // 在Xray中，任何不符合上述路由规则的流量，都会默认使用【第一个outbound（5.1）】的设置，所以一定要把转发VPS的outbound放第一个 ] }, // 4_入站设置 \u0026#34;inbounds\u0026#34;: [ // 4.1 一般都默认使用socks5协议作本地转发 { \u0026#34;tag\u0026#34;: \u0026#34;socks-in\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, // 这个是通过socks5协议做本地转发的地址 \u0026#34;port\u0026#34;: 10800, // 这个是通过socks5协议做本地转发的端口 \u0026#34;settings\u0026#34;: { \u0026#34;udp\u0026#34;: true } }, // 4.2 有少数APP不兼容socks协议，需要用http协议做转发，则可以用下面的端口 { \u0026#34;tag\u0026#34;: \u0026#34;http-in\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;listen\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, // 这个是通过http协议做本地转发的地址 \u0026#34;port\u0026#34;: 10801 // 这个是通过http协议做本地转发的端口 } ], // 5_出站设置 \u0026#34;outbounds\u0026#34;: [ // 5.1 默认转发VPS // 一定放在第一个，在routing 3.5 里面已经说明了，这等于是默认规则，所有不符合任何规则的流量都走这个 { \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vless\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;a-name.yourdomain.com\u0026#34;, // 替换成你的真实域名 \u0026#34;port\u0026#34;: 443, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;uuiduuid-uuid-uuid-uuid-uuiduuiduuid\u0026#34;, // 和服务器端的一致 \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, // Windows, macOS 同学保持这个不变 // \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-splice\u0026#34;, // Linux和安卓同学请改成Splice性能更强 \u0026#34;encryption\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] } ] }, \u0026#34;streamSettings\u0026#34;: { \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;xtls\u0026#34;, \u0026#34;xtlsSettings\u0026#34;: { \u0026#34;serverName\u0026#34;: \u0026#34;a-name.yourdomain.com\u0026#34;, // 替换成你的真实域名 \u0026#34;allowInsecure\u0026#34;: false // 禁止不安全证书 } } }, // 5.2 用`freedom`协议直连出站，即当routing中指定\u0026#39;direct\u0026#39;流出时，调用这个协议做处理 { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34; }, // 5.3 用`blackhole`协议屏蔽流量，即当routing中指定\u0026#39;block\u0026#39;时，调用这个协议做处理 { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;blackhole\u0026#34; } ] }    8.4 附加题 2：在PC端手工运行 xray-core  写好了配置文件该，要怎么让 xray-core 运行起来呢？双击好像并没有反应啊？\n首先，你要找到电脑上的【命令行界面】。\n Linux桌面、macOS系统的同学肯定已经比较熟悉了，搜索 Console 或者 Terminal 就可以 Windows就可以搜索使用 Cmd 或者 Powershell 等程序（WSL的同学你坐下，你的 Console 当然也可以）  其次，我们要做的事情是【让 xray 找到并读取配置文件 config.json，然后运行】，所以：\n  在Windows下，假设你的 Xray 程序位置是 C:\\Xray-windows-64\\xray.exe，配置文件位置是C:\\Xray-windows-64\\config.json，那么正确的启动命令就是：\nC:\\Xray-windows-64\\xray.exe -c C:\\Xray-windows-64\\config.json  说明： 这里的 -c 就是指定配置文件路径的参数，告诉 xray 去后面的位置找配置文件\n   相似的，在Linux和macOS下，假设你的 Xray 程序位置是 /usr/local/bin/xray，配置文件位置是/usr/local/etc/xray/config.json，那么正确的启动命令就是\n$ /usr/local/bin/xray -c /usr/local/etc/xray/config.json  说明： 每个系统都有系统路径变量，所以写 Xray 程序时不一定要写绝对路径。但是写了肯定没错，所以我就如此演示了。\n    8.5 附加题 3：在PC端开机自动运行 xray-core  如果你真的尝试了手动运行 xray-core，你一定会发现这个方式还有点小问题：\n 每次运行 Xray 都要出现一个黑乎乎的窗口，很丑 不能开机自动运行，每次都要手工输入，十分不方便  我可以肯定的告诉你：完全可以解决。但是具体的解决方式，就当作课外作业留给大家吧！（友情提示，文档站的问答区有线索哦）\n 8.6 圆满完成！  我相信，有耐心看到这里的同学，都是兼具好奇心和行动力的学习派！我现在要郑重的恭喜你，因为到了这里，你已经完完整整的【从第一条命令开始，完成了VPS服务器部署，并成功的在客户端配置使用Xray】了！这毫无疑问是一个巨大的胜利！\n我相信，你现在一定对Linux不再恐惧，对Xray不再陌生了吧！\n至此，小小白白话文圆满结束！ ⬛⬛⬛⬛⬛⬛⬛⬛ 100%\n 8.7 TO INFINITY AND BEYOND!  但现在你看到的，远远不是Xray的全貌。\nXray是一个强大而丰富的网络工具集合，平台化的提供了众多模块，可以像瑞士军刀一样，通过灵活的配置组合解决各种不同的问题。而本文，仅仅蜻蜓点水的用了最简单、最直观的配置来做基础演示。\n如果你觉得现在已经完全够用了，那就好好的享受它给你带来的信息自由。但如果你的好奇心依然不能停歇，那就去继续挖掘它无限的可能性吧！\n需要更多信息，可以到这里寻找：\n xtls.github.io - 官方文档站 官方Telegram群组 - 活跃而友善的官方讨论社区  不算后记的后记：\n希望我陪你走过的这一段小小的旅程，可以成为你网络生活中的一份小小助力。\n这篇文章里的工具和信息难免会一点点的陈旧过时，但你一定会逐渐成长为大佬。未来的某个时间，若你能偶尔想起这篇教程、想起我写下本文的初衷，那我衷心希望你能够薪火相传、把最新的知识分享给后来人，让这一份小小的助力在社区里坚定的传递下去。\n这是个大雪封山乌云密布的世界，人们孤独的走在各自的路上试图寻找阳光，如果大家偶尔交汇时不能守望相助互相鼓励，那最终剩下的，恐怕只有【千山鸟飞绝 万径人踪灭】的凄凉了吧。\n "},{"uri":"https://xtls.github.io/en/config/fallback/","title":"Fallbacks","tags":[],"description":"Project X 的文档.","content":" Fallback 是 Xray 的最强大功能之一, 可有效防止主动探测, 自由配置常用端口多服务共享 \nIn progress\n\nfallback 为 Xray 提供了高强度的防主动探测性, 并且具有独创的首包回落机制.\nfallback 也可以将不同类型的流量根据 path 进行分流, 从而实现一个端口, 多种服务共享.\n目前您可以在使用 VLESS 或者 trojan 协议时, 通过配置 fallbacks 来使用回落这一特, 并且创造出非常丰富的组合玩法.\nfallbacks 配置 \u0026#34;fallbacks\u0026#34;: [ { \u0026#34;dest\u0026#34;: 80 } ]  fallbacks: [ FallbackObject ]\n 一个数组，包含一系列强大的回落分流配置。\n\nFallbackObject  { \u0026#34;alpn\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;dest\u0026#34;: 80, \u0026#34;xver\u0026#34;: 0 } fallbacks 是一个数组，这里是其中一个子元素的配置说明。\nfallbacks 项是可选的，只能用于 TCP+TLS 传输组合\n 该项有子元素时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;http/1.1\u0026quot;]。**  通常，你需要先设置一组 alpn 和 path 均省略或为空的默认回落，然后再按需配置其它分流。\nVLESS 会把 TLS 解密后首包长度 \u0026lt; 18 或协议版本无效、身份认证失败的流量转发到 dest 指定的地址。\n其它传输组合必须删掉 fallbacks 项或所有子元素，此时也不会开启 Fallback，VLESS 会等待读够所需长度，协议版本无效或身份认证失败时，将直接断开连接。\nalpn: string\n 尝试匹配 TLS ALPN 协商结果，空为任意，默认为 \u0026quot;\u0026quot;\n有需要时，VLESS 才会尝试读取 TLS ALPN 协商结果，若成功，输出 info realAlpn = 到日志。 用途：解决了 Nginx 的 h2c 服务不能同时兼容 http/1.1 的问题，Nginx 需要写两行 listen，分别用于 1.1 和 h2c。 注意：fallbacks alpn 存在 \u0026quot;h2\u0026quot; 时，Inbound TLS 需设置 \u0026quot;alpn\u0026quot;:[\u0026quot;h2\u0026quot;,\u0026quot;http/1.1\u0026quot;]，以支持 h2 访问。\nTIP\nFallback 内设置的 \u0026ldquo;alpn\u0026rdquo; 是匹配实际协商出的 ALPN，而 Inbound TLS 设置的 \u0026ldquo;alpn\u0026rdquo; 是握手时可选的 ALPN 列表，两者含义不同。\n path: string\n 尝试匹配首包 HTTP PATH，空为任意，默认为空，非空则必须以 \u0026quot;/\u0026quot; 开头，不支持 h2c。\n智能：有需要时，VLESS 才会尝试看一眼 PATH（不超过 55 个字节；最快算法，并不完整解析 HTTP），若成功，输出 info realPath = 到日志。 用途：分流其它 inbound 的 WebSocket 流量或 HTTP 伪装流量，没有多余处理、纯粹转发流量，实测比 Nginx 反代更强。\n注意：fallbacks 所在入站本身必须是 TCP+TLS，这是分流至其它 WS 入站用的，被分流的入站则无需配置 TLS。\ndest: string | number\n 决定 TLS 解密后 TCP 流量的去向，目前支持两类地址：（该项必填，否则无法启动）\n TCP，格式为 \u0026quot;addr:port\u0026quot;，其中 addr 支持 IPv4、域名、IPv6，若填写域名，也将直接发起 TCP 连接（而不走内置的 DNS）。 Unix domain socket，格式为绝对路径，形如 \u0026quot;/dev/shm/domain.socket\u0026quot;，可在开头加 \u0026quot;@\u0026quot; 代表 abstract，\u0026quot;@@\u0026quot; 则代表带 padding 的 abstract。  若只填 port，数字或字符串均可，形如 80、\u0026quot;80\u0026quot;，通常指向一个明文 http 服务（addr 会被补为 \u0026quot;127.0.0.1\u0026quot;）。\nxver: number\n 发送 PROXY protocol，专用于传递请求的真实来源 IP 和端口，填版本 1 或 2，默认为 0，即不发送。若有需要建议填 1。\n目前填 1 或 2，功能完全相同，只是结构不同，且前者可打印，后者为二进制。Xray 的 TCP 和 WS 入站均已支持接收 PROXY protocol。\nTIP\n若你正在 配置 Nginx 接收 PROXY protocol，除了设置 proxy_protocol 外，还需设置 set_real_ip_from，否则可能会出问题。\n \n补充说明   将匹配到最精确的子元素，与子元素的排列顺序无关。若配置了几个 alpn 和 path 均相同的子元素，则会以最后的为准。 回落分流均是解密后 TCP 层的转发，而不是 HTTP 层，只在必要时检查首包 PATH。 不支持按域名分流。若有此需求，建议前置 Nginx 等并配置 stream SNI 分流。  "},{"uri":"https://xtls.github.io/en/config/inbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n InboundConfigurationObject { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;aes-256-gcm\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; }  email: string\n 邮件地址，可选，用于标识用户\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填，任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\nnetwork: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;udp\u0026rdquo; | \u0026ldquo;tcp,udp\u0026rdquo;\n 可接收的网络协议类型。比如当指定为 \u0026quot;tcp\u0026quot; 时，仅会接收 TCP 流量。默认值为 \u0026quot;tcp\u0026quot;。\n"},{"uri":"https://xtls.github.io/en/config/outbound-protocols/trojan/","title":"Trojan","tags":[],"description":"Project X 的文档.","content":"Trojan 协议\nimportantTrojan 被设计工作在正确配置的加密 TLS 隧道\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ ServerObject ]\n 一个数组，其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;password\u0026#34;: \u0026#34;password\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;flow\u0026#34;: \u0026#34;xtls-rprx-direct\u0026#34;, \u0026#34;level\u0026#34;: 0 }  address: address\n 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n 服务端端口，通常与服务端监听的端口相同。\npassword: string\n 密码. 必填，任意字符串。\nemail: string\n 邮件地址，可选，用于标识用户\nflow: string\n 流控模式，用于选择 XTLS 的算法。\n目前出站协议中有以下流控模式可选：\n xtls-rprx-origin：最初的流控模式。该模式纪念价值大于实际使用价值 xtls-rprx-origin-udp443：同 xtls-rprx-origin, 但放行了目标为 443 端口的 UDP 流量 xtls-rprx-direct：所有平台皆可使用的典型流控模式 xtls-rprx-direct-udp443：同 xtls-rprx-direct, 但是放行了目标为 443 端口的 UDP 流量 xtls-rprx-splice：Linux 平台下最建议使用的流控模式 xtls-rprx-splice-udp443：同 xtls-rprx-splice, 但是放行了目标为 443 端口的 UDP 流量  注意\n当 flow 被指定时，还需要将该出站协议的 streamSettings.security 一项指定为 xtls，tlsSettings 改为 xtlsSettings。详情请参考 streamSettings。\n此外，目前 XTLS 仅支持 TCP、mKCP、DomainSocket 这三种传输方式。\n 关于 xtls-rprx-*-udp443 流控模式\nVLESS 和 Trojan 协议使用 TCP 传输 UDP，即 UDP over TCP，但 XTLS 不会对 UoT 的数据进行处理。所以为了防止上层应用使用 QUIC，启用 XTLS 时客户端会自动拦截 UDP/443 的请求。若不需要拦截，请在客户端填写 xtls-rprx-*-udp443，服务端不变。\n importantSplice 是 Linux Kernel 提供的函数，系统内核直接转发 TCP，不再经过 Xray 的内存，大大减少了数据拷贝、CPU 上下文切换的次数。\nSplice 模式的的使用限制：\n Linux 环境 入站协议为 Dokodemo door、Socks、HTTP 等纯净的 TCP 连接, 或其它使用了 XTLS 的入站协议 出站协议为 VLESS + XTLS 或 Trojan + XTLS  此外，使用 Splice 时网速显示会滞后，这是特性，不是 bug。\n需要注意的是，使用 mKCP 协议时不会使用 Splice（是的，虽然没有报错，但实际上根本没用到）。\n level: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/en/config/base/transport/","title":"传输方式","tags":[],"description":"Project X 的文档.","content":"传输方式（transport）是当前 Xray 节点和其它节点对接的方式。\n传输方式指定了稳定的数据传输的方式。通常来说，一个网络连接的两端需要有对称的传输方式。比如一端用了 WebSocket，那么另一个端也必须使用 WebSocket，否则无法建立连接。\n传输方式（transport）配置有两部分:\n  全局设置（TransportObject）\n  指定inbound/outbound配置（StreamSettingsObject）。\n指定inbound/outbound配置时,可以指定每个单独的inbound/outbound用怎样的方式传输。\n通常来说客户端和服务器对应的inbound和outbound需要使用同样的传输方式。当inbound/outbound配置指定了一种传输方式，但没有填写其具体设置时，此传输方式会使用全局配置中的设置。\n  \nTransportObject  TransportObject 对应配置文件的 transport 项。\n{ \u0026#34;transport\u0026#34;: { \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {} } }  tcpSettings: TcpObject\n 针对 TCP 连接的配置。\nkcpSettings: KcpObject\n 针对 mKCP 连接的配置。\nwsSettings: WebSocketObject\n 针对 WebSocket 连接的配置。\nhttpSettings: HttpObject\n 针对 HTTP/2 连接的配置。\nquicSettings: QuicObject\n 针对 QUIC 连接的配置。\ndsSettings: DomainSocketObject\n 针对 Domain Socket 连接的配置。\n\nStreamSettingsObject  StreamSettingsObject 对应inbound/outbound中的 streamSettings 项。每一个 inbound/outbound 都可以分别配置不同的传输配置，都可以设置 streamSettings 来进行一些传输的配置。\n{ \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;tlsSettings\u0026#34;: {}, \u0026#34;xtlsSettings\u0026#34;: {}, \u0026#34;tcpSettings\u0026#34;: {}, \u0026#34;kcpSettings\u0026#34;: {}, \u0026#34;wsSettings\u0026#34;: {}, \u0026#34;httpSettings\u0026#34;: {}, \u0026#34;quicSettings\u0026#34;: {}, \u0026#34;dsSettings\u0026#34;: {}, \u0026#34;sockopt\u0026#34;: { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34; } }  network: \u0026ldquo;tcp\u0026rdquo; | \u0026ldquo;kcp\u0026rdquo; | \u0026ldquo;ws\u0026rdquo; | \u0026ldquo;http\u0026rdquo; | \u0026ldquo;domainsocket\u0026rdquo; | \u0026ldquo;quic\u0026rdquo;\n 连接的数据流所使用的传输方式类型，默认值为 \u0026quot;tcp\u0026quot;\nsecurity: \u0026ldquo;none\u0026rdquo; | \u0026ldquo;tls\u0026rdquo; | \u0026ldquo;xtls\u0026rdquo;\n 是否启用传输层加密，支持的选项有\n \u0026quot;none\u0026quot; 表示不加密（默认值） \u0026quot;tls\u0026quot; 表示使用 TLS。 \u0026quot;xtls\u0026quot; 表示使用 XTLS。  tlsSettings: TLSObject\n TLS 配置。TLS 由 Golang 提供，通常情况下TLS协商的结果为使用 TLS 1.3，不支持 DTLS。\nxtlsSettings: XTLSObject\n XTLS 配置。XTLS 是 Xray 的原创黑科技, 也是使 Xray 性能一骑绝尘的核心动力.\nXTLS 与 TLS 有相同的安全性, 配置方式也和TLS一致. 点击此处查看XTLS的技术细节剖析 importantTLS / XTLS 是目前最安全的传输加密方案, 且外部看来流量类型和正常上网具有一致性.\n启用 XTLS 并且配置合适的XTLS流控模式, 可以在保持和 TLS 相同的安全性的前提下, 性能达到数倍甚至十几倍的提升.\n当 security 的值从\u0026rsquo;tls\u0026rsquo;改为\u0026rsquo;xtls\u0026rsquo;时, 只需将tlsSettings 修改成为 xtlsSettings\n tcpSettings: TcpObject\n 当前连接的 TCP 配置，仅当此连接使用 TCP 时有效。配置内容与上面的全局配置相同。\nkcpSettings: KcpObject\n 当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。配置内容与上面的全局配置相同。\nwsSettings: WebSocketObject\n 当前连接的 WebSocket 配置，仅当此连接使用 WebSocket 时有效。配置内容与上面的全局配置相同。\nhttpSettings: HttpObject\n 当前连接的 HTTP/2 配置，仅当此连接使用 HTTP/2 时有效。配置内容与上面的全局配置相同。\nquicSettings: QUICObject\n 当前连接的 QUIC 配置，仅当此连接使用 QUIC 时有效。配置内容与上面的全局配置相同。\ndsSettings: DomainSocketObject\n 当前连接的 Domain socket 配置，仅当此连接使用 Domain socket 时有效。配置内容与上面的全局配置相同。\nsockopt: SockoptObject\n 透明代理相关的具体配置。\n\nTLSObject  { \u0026#34;serverName\u0026#34;: \u0026#34;xray.com\u0026#34;, \u0026#34;allowInsecure\u0026#34;: false, \u0026#34;alpn\u0026#34;: [ \u0026#34;h2\u0026#34;, \u0026#34;http/1.1\u0026#34; ], \u0026#34;minVersion\u0026#34;: \u0026#34;1.2\u0026#34;, \u0026#34;maxVersion\u0026#34;: \u0026#34;1.3\u0026#34;, \u0026#34;preferServerCipherSuites\u0026#34;: true, \u0026#34;cipherSuites\u0026#34;: \u0026#34;此处填写你需要的加密套件名称,每个套件名称之间用:进行分隔\u0026#34;, \u0026#34;certificates\u0026#34;: [], \u0026#34;disableSystemRoot\u0026#34;: false \u0026#34;enableSessionResumption\u0026#34;: false }  serverName: string\n 指定服务器端证书的域名，在连接由 IP 建立时有用。\n当目标连接由域名指定时，比如在 Socks inbound接收到了域名，或者由 Sniffing 功能探测出了域名，这个域名会自动用于 serverName，无须手动配置。\nalpn: [ string ]\n 一个字符串数组，指定了 TLS 握手时指定的 ALPN 数值。默认值为 [\u0026quot;h2\u0026quot;, \u0026quot;http/1.1\u0026quot;]。\nminVersion: [ string ]\n minVersion为可接受的最小SSL/TLS版本。\nmaxVersion: [ string ]\n maxVersion为可接受的最大SSL/TLS版本。\npreferServerCipherSuites: true | false\n 指示服务器选择客户端最喜欢的密码套件 或 服务器最优选的密码套件。\n如果为true则为使用服务器的最优选的密码套件\ncipherSuites: [ string ]\n CipherSuites用于配置受支持的密码套件列表, 每个套件名称之间用:进行分隔.\n你可以在这里或这里找到golang加密套件的名词和说明\nimportant以上两项配置为非必要选项，正常情况下不影响安全性 在未配置的情况下golang根据设备自动选择. 若不熟悉, 请勿配置此选项, 填写不当引起的问题自行负责\n allowInsecure: true | false\n 是否允许不安全连接（仅用于客户端）。默认值为 false。\n当值为 true 时，Xray 不会检查远端主机所提供的 TLS 证书的有效性。\nimportant出于安全性考虑，这个选项不应该在实际场景中选择true，否则可能遭受中间人攻击。\n disableSystemRoot: true | false\n 是否禁用操作系统自带的 CA 证书。默认值为 false。\n当值为 true 时，Xray 只会使用 certificates 中指定的证书进行 TLS 握手。当值为 false 时，Xray 只会使用操作系统自带的 CA 证书进行 TLS 握手。\nenableSessionResumption: true | false\n 此参数的设置为false时, ClientHello 里没有 session_ticket 这个扩展。\n通常来讲 go 语言程序的 ClientHello 里并没有用到这个扩展, 因此建议保持默认值。\n默认值为 false。\ncertificates: [ CertificateObject ]\n 证书列表，其中每一项表示一个证书（建议 fullchain）。\nTIP\n如果要在 ssllibs 或者 myssl 获得 A/A+ 等级的评价, 请参考这里.\n CertificateObject { \u0026#34;ocspStapling\u0026#34;: 3600, \u0026#34;usage\u0026#34;: \u0026#34;encipherment\u0026#34;, \u0026#34;certificateFile\u0026#34;: \u0026#34;/path/to/certificate.crt\u0026#34;, \u0026#34;keyFile\u0026#34;: \u0026#34;/path/to/key.key\u0026#34;, \u0026#34;certificate\u0026#34;: [ \u0026#34;-----BEGIN CERTIFICATE-----\u0026#34;, \u0026#34;MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw\u0026#34;, \u0026#34;ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3\u0026#34;, \u0026#34;DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+\u0026#34;, \u0026#34;3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw\u0026#34;, \u0026#34;OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5\u0026#34;, \u0026#34;pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON\u0026#34;, \u0026#34;OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp\u0026#34;, \u0026#34;noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G\u0026#34;, \u0026#34;A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA\u0026#34;, \u0026#34;MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU\u0026#34;, \u0026#34;7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+\u0026#34;, \u0026#34;9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO\u0026#34;, \u0026#34;6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8\u0026#34;, \u0026#34;r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/\u0026#34;, \u0026#34;d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q\u0026#34;, \u0026#34;-----END CERTIFICATE-----\u0026#34; ], \u0026#34;key\u0026#34;: [ \u0026#34;-----BEGIN RSA PRIVATE KEY-----\u0026#34;, \u0026#34;MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh\u0026#34;, \u0026#34;bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9\u0026#34;, \u0026#34;GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n\u0026#34;, \u0026#34;jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN\u0026#34;, \u0026#34;itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq\u0026#34;, \u0026#34;IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw\u0026#34;, \u0026#34;qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue\u0026#34;, \u0026#34;C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap\u0026#34;, \u0026#34;/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM\u0026#34;, \u0026#34;aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW\u0026#34;, \u0026#34;/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4\u0026#34;, \u0026#34;bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ\u0026#34;, \u0026#34;8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi\u0026#34;, \u0026#34;pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR\u0026#34;, \u0026#34;L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG\u0026#34;, \u0026#34;3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7\u0026#34;, \u0026#34;az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK\u0026#34;, \u0026#34;gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH\u0026#34;, \u0026#34;TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8\u0026#34;, \u0026#34;eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW\u0026#34;, \u0026#34;64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q\u0026#34;, \u0026#34;8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2\u0026#34;, \u0026#34;GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq\u0026#34;, \u0026#34;ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR\u0026#34;, \u0026#34;cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT\u0026#34;, \u0026#34;-----END RSA PRIVATE KEY-----\u0026#34; ] }  ocspStapling: number\n ocspStapling 检查更新时间间隔。 单位：秒\nusage: \u0026ldquo;encipherment\u0026rdquo; | \u0026ldquo;verify\u0026rdquo; | \u0026ldquo;issue\u0026rdquo;\n 证书用途，默认值为 \u0026quot;encipherment\u0026quot;。\n \u0026quot;encipherment\u0026quot;：证书用于 TLS 认证和加密。 \u0026quot;verify\u0026quot;：证书用于验证远端 TLS 的证书。当使用此项时，当前证书必须为 CA 证书。 \u0026quot;issue\u0026quot;：证书用于签发其它证书。当使用此项时，当前证书必须为 CA 证书。  TIP 1\n在 Windows 平台上可以将自签名的 CA 证书安装到系统中，即可验证远端 TLS 的证书。\n TIP 2\n当有新的客户端请求时，假设所指定的 serverName 为 \u0026quot;xray.com\u0026quot;，Xray 会先从证书列表中寻找可用于 \u0026quot;xray.com\u0026quot; 的证书，如果没有找到，则使用任一 usage 为 \u0026quot;issue\u0026quot; 的证书签发一个适用于 \u0026quot;xray.com\u0026quot; 的证书，有效期为一小时。并将新的证书加入证书列表，以供后续使用。\n TIP 3\n当 certificateFile 和 certificate 同时指定时，Xray 优先使用 certificateFile。keyFile 和 key 也一样。\n TIP 4\n当 usage 为 \u0026quot;verify\u0026quot; 时，keyFile 和 key 可均为空。\n TIP 5\n使用 xray tls cert 可以生成自签名的 CA 证书。\n TIP 6\n如已经拥有一个域名, 可以使用工具便捷的获取免费第三方证书,如acme.sh\n certificateFile: string\n 证书文件路径，如使用 OpenSSL 生成，后缀名为 .crt。\ncertificate: [ string ]\n 一个字符串数组，表示证书内容，格式如样例所示。certificate 和 certificateFile 二者选一。\nkeyFile: string\n 密钥文件路径，如使用 OpenSSL 生成，后缀名为 .key。目前暂不支持需要密码的 key 文件。\nkey: [ string ]\n 一个字符串数组，表示密钥内容，格式如样例如示。key 和 keyFile 二者选一。\n\nSockoptObject  { \u0026#34;mark\u0026#34;: 0, \u0026#34;tcpFastOpen\u0026#34;: false, \u0026#34;tproxy\u0026#34;: \u0026#34;off\u0026#34; }  mark: number\n 一个整数。当其值非零时，在ountbound连接以此数值上标记 SO_MARK。\n 仅适用于 Linux 系统。 需要 CAP_NET_ADMIN 权限。  tcpFastOpen: true | false\n 是否启用 TCP Fast Open。\n当其值为 true 时，强制开启 TFO；当其值为 false 时，强制关闭 TFO；当此项不存在时，使用系统默认设置。 可用于inbound/ountbound。\n 仅在以下版本（或更新版本）的操作系统中可用:  Windows 10 (1604) Mac OS 10.11 / iOS 9 Linux 3.16：系统已默认开启，无需配置。    tproxy: \u0026ldquo;redirect\u0026rdquo; | \u0026ldquo;tproxy\u0026rdquo; | \u0026ldquo;off\u0026rdquo;\n 是否开启透明代理（仅适用于 Linux）。\n \u0026quot;redirect\u0026quot;：使用 Redirect 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;tproxy\u0026quot;：使用 TProxy 模式的透明代理。支持所有基于 IPv4/6 的 TCP 和 UDP 连接。 \u0026quot;off\u0026quot;：关闭透明代理。  透明代理需要 Root 或 CAP_NET_ADMIN 权限。\nimportant当 Dokodemo-door 中指定了 followRedirect为true，且 Sockopt设置中的tproxy 为空时，Sockopt设置中的tproxy 的值会被设为 \u0026quot;redirect\u0026quot;。\n "},{"uri":"https://xtls.github.io/en/faq/about/","title":"关于Xray","tags":[],"description":"Project X 的文档.","content":" Q: XXX功能什么时候出来呀!康明宋\n Q: 为什么会开发 Xray ?兴趣使然\n Q: Xray收钱吗? 可以按我的要求定制吗?Xray 不沾钱,这是个兴趣使然的项目.\nXray 不接受定制, 只根据大家的需求进行兴趣使然的开发.\n Q: XXX也是你们开发的吗?请明辨您获取资源的来源, 小心使用, 谨防蜜罐\n我们的开发均托管在 github, 不在project X 仓库的, 都不属于 project X 开发.\n当然也有很多大佬支持着 Xray 的开发和完善了生态圈, 请见这里.\n我们也欢迎所有人一起来完善 Xray.\n Q: Xray 和 v2ray 还有 v2fly 是什么关系啊?禁忌の歷史迷局\nv2ray-core 项目是继Shadowsocks项目之后活跃的独立项目。\n但在2019年，原作者Victoria Raymond突然从 GitHub 项目、社交网站等失联，开发一度陷入停滞。\nv2fly项目组基于v2ray项目的技术基础，fork并成立了社区化项目v2fly。\n后续于2020年9月与 GitHub 官方沟通确认后，取消了与原 v2ray 项目的fork关系，正式成为独立的社区项目组织。\n随后，v2fly社区的贡献者之一 rprx，给v2fly项目带来了VLESS协议，回落分流，XTLS黑科技等一系列更新，v2fly项目进入了\u0026quot;腹泻式\u0026quot;更新时期。\nv2fly社区一些成员在某些技术选择及社区理念方面与 rprx 产生分歧。\n此后在一些其他外因的促使下，v2fly社区自 v4.33.0 版本起移除了其核心对 XTLS 的支持，但保留了 VLESS 协议支持。\n最终 rprx 决定独立分支并成立 project X 社区进行维护。\n2020年11月25日，Xray 1.0正式发布，成为了基于原 v2ray 项目基础的第二个社区分支版本。\nXray 一直保持着前行，并且在将来也会保持不断前行，您可以在大史记查看 Xray 一路前行中发生的各种杂事秘辛。\n Xray 项目的核心技术创新是：\n  VLESS 协议\n  回落分流 防主动探测, 强大而且灵活的分流.\n  XTLS 及流控 保证数据流获得标准TLS加密的同时，借助readV, Zero Copy等技术，最大限度减少数据流转过程中冗余的资源使用（表现为性能大幅提升、CPU 占用大幅降低、网速和延迟接近接近硬件的极限）\n  Xray 项目的核心社区理念是：\n  活跃的开发社区\nXray 保持着活跃的开发与更新，项目成立至今保持着每周有效更新的节奏，积极倾听社区反馈和用户痛点，快速迭代新特性、并持续解决历史遗留问题（详情可直接参考相关 release notes）\n  明确的价值追求\nXray项目组反对技术壁垒化、倡导社区分享和互助，坚定维护友善积极的社区氛围。\n   \n"},{"uri":"https://xtls.github.io/en/links/","title":"常用链接","tags":[],"description":"Project X 的文档.","content":"安装脚本   Linux Script  Xray-install Xray-script 感谢@kirin   Docker  teddysun/xray 感谢@秋水逸冰 Xray-docker   One Click  ProxySU 感谢@ProxySu Xray-agent 感谢@mack-a   Magisk  Xray4Magisk 感谢@子曦曦 Xray_For_Magisk 感谢@E7KMbb    \n配置模板  所有的模板请传送至: Xray-examples\n包含了各种用法示范的终极配置: VLESS-TCP-XTLS-WHATEVER\n\n图形化客户端   OpenWrt  PassWall Hello World ShadowSocksR Plus+   Windows  v2rayN Qv2ray   Android  v2rayNG Kitsunebi   iOS / Mac  Shadowrocket    \nUUID 生成器  第三方的 UUID 生成器 uuidgenerator.net\n"},{"uri":"https://xtls.github.io/en/documents/level-0/ch09-appendix/","title":"【第9章】附录","tags":[],"description":"小小白白话文","content":"1. 小小白白Linux基础命令索引     编号 命令名称 命令说明 出现篇章     cmd-01 apt update 查询软件更新 《远程登录篇》   cmd-02 apt upgrade 执行软件更新 《远程登录篇》   cmd-03 nano 文本编辑器 《安全防护篇》   cmd-04 systemctl restart 重启某个服务 《安全防护篇》   cmd-05 adduser 给系统新增用户 《安全防护篇》   cmd-06 apt install 安装某个软件 《安全防护篇》   cmd-07 visudo 修改sudo权限设置专用编辑器 《安全防护篇》   cmd-08 sudo 用root权限运行某个命令 《安全防护篇》   cmd-09 chmod 修改目标文件/文件夹的权限 《安全防护篇》   cmd-10 mkdir 新建文件夹 《网站建设篇》   cmd-11 systemctl reload 重新加载某个服务 《网站建设篇》   cmd-12 wget 访问（或下载）某个网页文件 《证书管理篇》   cmd-13 acme.sh acme.sh证书管理相关的命令 《证书管理篇》   cmd-14 rm 删除命令 《Xray服务器篇》   cmd-15 crontab -e 编辑当前用户的定时任务 《Xray服务器篇》   cmd-16 touch 建立空白文件 《Xray服务器篇》   cmd-17 systemctl systemd基本服务管理命令 《Xray服务器篇》   cmd-18 reboot 重启Linux系统 《Xray服务器篇》     2. 小小白白Linux重要配置文件索引     编号 配置文件位置 文件说明 出现篇章     conf-01 /etc/ssh/sshd_config SSH远程登录程序设置 《远程登录篇》   conf-02 /etc/nginx/nginx.conf Nginx程序设置 《网站建设篇》   conf-03 /etc/apt/sources.list apt软件源列表 《Xray服务器篇》   conf-04 /etc/apt/sources.list.d/vpsadmin.list 用户自定义软件源列表列表 《Xray服务器篇》   conf-05 crontab -e 当前用户的定时任务 《Xray服务器篇》   conf-06 /etc/sysctl.conf 手动设置kernel参数 《Xray服务器篇》   conf-07 /etc/sysctl.d/vpsadmin.conf 用户自定义kernel参数配置文件 《Xray服务器篇》     3. 小小白白Xray重要文件索引     编号 配置文件位置 文件说明 出现篇章     xray-01 /usr/local/etc/xray/config.json Xray程序设置 《Xray服务器篇》   xray-02 /home/vpsadmin/xray_cert/xray.cert TLS证书 《Xray服务器篇》   xray-03 /home/vpsadmin/xray_cert/xray.key TLS私钥 《Xray服务器篇》   xray-04 /home/vpsadmin/xray_log/access.log Xray访问日志 《Xray服务器篇》   xray-05 /home/vpsadmin/xray_log/error.log Xray错误日志 《Xray服务器篇》    "},{"uri":"https://xtls.github.io/en/config/outbound-protocols/shadowsocks/","title":"Shadowsocks","tags":[],"description":"Project X 的文档.","content":"Shadowsocks 协议，兼容大部分其它版本的实现。\n目前兼容性如下：\n  支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；\n  推荐的加密方式：\n AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain  不推荐的加密方式:\n AES-256-CFB AES-128-CFB ChaCha20 ChaCha20-IETF    important\u0026ldquo;none\u0026rdquo; 不加密方式下，服务器端不会验证 \u0026ldquo;password\u0026rdquo; 中的密码。为确保安全性, 一般需要加上 TLS 并在传输层使用安全配置，例如 WebSocket 配置较长的 path\n OutboundConfigurationObject  { \u0026#34;servers\u0026#34;: [ { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 } ] }  servers: [ServerObject]\n 一个数组，代表一组 Shadowsocks 服务端设置, 其中每一项是一个 ServerObject。\n\nServerObject  { \u0026#34;email\u0026#34;: \u0026#34;love@xray.com\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 1234, \u0026#34;method\u0026#34;: \u0026#34;加密方式\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;密码\u0026#34;, \u0026#34;level\u0026#34;: 0 }  email: string\n 邮件地址，可选，用于标识用户\naddress: address\n Shadowsocks 服务端地址，支持 IPv4、IPv6 和域名。必填。\nport: number\n Shadowsocks 服务端端口。必填。\nmethod: string\n 必填。\n 推荐的加密方式：  AES-256-GCM AES-128-GCM ChaCha20-Poly1305 或称 ChaCha20-IETF-Poly1305 none 或 plain    password: string\n 必填。任意字符串。\nShadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。\nlevel: number\n 用户等级，连接会使用这个用户等级对应的本地策略。\nlevel 的值, 对应 policy 中 level 的值. 如不指定, 默认为 0.\n"},{"uri":"https://xtls.github.io/en/config/base/stats/","title":"统计信息","tags":[],"description":"Project X 的文档.","content":"用于配置 Xray 流量数据的统计。\nStatsObject StatsObject 对应配置文件的 stats 项。\n{ \u0026#34;stats\u0026#34;: {} } 目前统计信息不需要任何参数，只要 StatsObject 项存在，内部的统计即会开启。\n开启了统计以后, 只需在 Policy 中开启对应的项，就可以统计对应的数据。\n\n获取统计信息  可以用 xray api 的相关命令获取统计信息.\n目前已有的统计信息如下：\n  用户数据\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定用户的上行流量，单位字节。\n  user\u0026gt;\u0026gt;\u0026gt;[email]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定用户的下行流量，单位字节。\n  TIP\n如果对应用户没有指定 Email，则不会开启统计。\n   全局数据\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定inbound的上行流量，单位字节。\n  inbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定inbound的下行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;uplink\n特定outbound的上行流量，单位字节。\n  outbound\u0026gt;\u0026gt;\u0026gt;[tag]\u0026gt;\u0026gt;\u0026gt;traffic\u0026gt;\u0026gt;\u0026gt;downlink\n特定outbound的下行流量，单位字节。\n    "},{"uri":"https://xtls.github.io/en/config/base/reverse/","title":"反向代理","tags":[],"description":"Project X 的文档.","content":"反向代理可以把服务器端的流量向客户端转发，即逆向流量转发。\n反向代理的大致工作原理如下:\n 假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流量从 B 转发到 A。 在主机 A 中配置 Xray，称为bridge，在 B 中也配置 Xray，称为 portal。 bridge 会向 portal 主动建立连接，此连接的目标地址可以自行设定。portal 会收到两种连接，一是由 bridge 发来的连接，二是公网用户发来的连接。portal 会自动将两类连接合并。于是 bridge 就可以收到公网流量了。 bridge 在收到公网流量之后，会将其原封不动地发给主机 A 中的网页服务器。当然，这一步需要路由的协作。 bridge 会根据流量的大小进行动态的负载均衡。  TIP\n反向代理默认已开启 Mux，请不要在其用到的outbound上再次开启 Mux。\n 反向代理功能尚处于测试阶段，可能会有一些问题。\n \nReverseObject  ReverseObject 对应配置文件的 reverse 项。\n{ \u0026#34;reverse\u0026#34;: { \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ], \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } }  bridges: [BridgeObject]\n 数组，每一项表示一个 bridge。每个 bridge 的配置是一个 BridgeObject。\nportals: [PortalObject]\n 数组，每一项表示一个 portal。每个 portal 的配置是一个 PortalObject。\n\nBridgeObject  { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n 所有由 bridge 发出的连接，都会带有这个标识。可以在 路由配置 中使用 inboundTag 进行识别。\ndomain: string\n 指定一个域名，bridge 向 portal 建立的连接，都会使用这个域名进行发送。\n这个域名只作为 bridge 和 portal 的通信用途，不必真实存在。\n\nPortalObject  { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; }  tag: string\n portal 的标识。在 路由配置 中使用 outboundTag 将流量转发到这个 portal。\ndomain: string\n 一个域名。当 portal 接收到流量时，如果流量的目标域名是此域名，则 portal 认为当前连接上 bridge 发来的通信连接。而其它流量则会被当成需要转发的流量。portal 所做的工作就是把这两类连接进行识别并拼接。\nTIP\n一个 Xray 既可以作为 bridge，也可以作为 portal，也可以同时两者，以适用于不同的场景需要。\n \n完整配置样例  TIP\n在运行过程中，建议先启用 bridge，再启用 portal。\n bridge配置  bridge 通常需要两个outbound，一个用于连接 portal，另一个用于发送实际的流量。也就是说，你需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;bridges\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;bridge\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; } ] } outbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;out\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;freedom\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;redirect\u0026#34;: \u0026#34;127.0.0.1:80\u0026#34; // 将所有流量转发到网页服务器 } }, { \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;vnext\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;portal 的 IP 地址\u0026#34;, \u0026#34;port\u0026#34;: 1024, \u0026#34;users\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34; } ] } ] }, \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34; } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;domain\u0026#34;: [ \u0026#34;full:test.xray.com\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;interconn\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;bridge\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;out\u0026#34; } ] } \nportal配置  portal 通常需要两个inbound，一个用于接收 bridge 的连接，另一个用于接收实际的流量。同时你也需要用路由区分两种流量。\n反向代理配置:\n{ \u0026#34;portals\u0026#34;: [ { \u0026#34;tag\u0026#34;: \u0026#34;portal\u0026#34;, \u0026#34;domain\u0026#34;: \u0026#34;test.xray.com\u0026#34; // 必须和 bridge 的配置一样 } ] } inbound:\n{ \u0026#34;tag\u0026#34;: \u0026#34;external\u0026#34;, \u0026#34;port\u0026#34;: 80, // 开放 80 端口，用于接收外部的 HTTP 访问 \u0026#34;protocol\u0026#34;: \u0026#34;dokodemo-door\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;address\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;: 80, \u0026#34;network\u0026#34;: \u0026#34;tcp\u0026#34; } }, { \u0026#34;port\u0026#34;: 1024, // 用于接收 bridge 的连接 \u0026#34;tag\u0026#34;: \u0026#34;interconn\u0026#34;, \u0026#34;protocol\u0026#34;: \u0026#34;vmess\u0026#34;, \u0026#34;settings\u0026#34;: { \u0026#34;clients\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;5783a3e7-e373-51cd-8642-c83782b807c5\u0026#34; } ] } } 路由配置:\n\u0026#34;routing\u0026#34;: { \u0026#34;rules\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;external\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;field\u0026#34;, \u0026#34;inboundTag\u0026#34;: [ \u0026#34;interconn\u0026#34; ], \u0026#34;outboundTag\u0026#34;: \u0026#34;portal\u0026#34; } ] } "},{"uri":"https://xtls.github.io/en/config/xtls/","title":"XTLS","tags":[],"description":"Project X Documents","content":" XTLS is the xray’s original futuristic technology, and the core of what makes the xray so powerful. \nIn progress\n"},{"uri":"https://xtls.github.io/en/config/env/","title":"Environment Variables","tags":[],"description":"Project X Documents","content":"Xray provides the following environment variables for modifying some of xray\u0026rsquo;s underlying configuration.\n\nXTLS information display  VLESS   Name: xray.vless.xtls.show or XRAY_VLESS_XTLS_SHOW. Default value: \u0026quot;\u0026quot;.  If this environment variable is set to true when using the VLESS protocol, xray will output information about XTLS in the terminal or logs.\nTIP\nYou can turn on this environment variable and determine if XTLS has been successfully applied based on whether XTLS-related information is output.\n TROJAN   Name: xray.trojan.xtls.show or XRAY_TROJAN_XTLS_SHOW. Default value: \u0026quot;\u0026quot;.  If this environment variable is set to true when using the trojan protocol, xray will output information about XTLS in the terminal or logs.\nTIP\nYou can turn on this environment variable and determine if XTLS has been successfully applied based on whether XTLS-related information is output.\n \nResource file path   Name: xray.location.asset or XRAY_LOCATION_ASSET. Default value: same path as xray file.  This environment variable specifies a folder location which should contain the geoip.dat and geosite.dat files.\n\nConfiguration file location   Name: xray.location.config or XRAY_LOCATION_CONFIG. Default value: same path as xray file.  This environment variable specifies the location of a folder that should contain the config.json file.\n\nMulti-configuration directory   Name: xray.location.confdir or XRAY_LOCATION_CONFDIR. Default value: \u0026quot;\u0026quot;.  The .json files in this directory are read in filename order as a multi-configuration option.\n\n"},{"uri":"https://xtls.github.io/en/config/multiple_config/","title":"多文件配置","tags":[],"description":"Project X 的文档.","content":"Xray 程序支持使用多个配置文件。\n多配置文件的主要作用在于分散不同作用模块配置，便于管理和维护。\n该功能主要考虑是为了丰富 Xray 的生态链，比如对于 GUI 的客户端，一般只实现节点选择等固定的功能，对于太复杂的配置难以图形化实现；只需留一个 confdir 的自定义配置目录供配置复杂的功能；对于服务器的部署脚本，只需往 confdir 添加文件即可实现配置多种协议。\n多文件启动  TIP\n启动信息中会提示依次读入的每个配置文件，留意启动信息是否符合你预设的顺序。\n $ xray run -confdir /etc/xray/confs 也可使用 Xray.location.confdir 或 Xray_LOCATION_CONFDIR 指定 confdir。\n参数 -confdir 的作用优先于环境变量，如果参数指定了有效的目录则不再读取环境变量中的路径。\n\n规则说明  普通对象（{}）  在 json 的顶级对象当中，后者覆盖或补充前者。\n比如：\n base.json  { \u0026#34;log\u0026#34;: {}, \u0026#34;api\u0026#34;: {}, \u0026#34;dns\u0026#34;: {}, \u0026#34;stats\u0026#34;: {}, \u0026#34;policy\u0026#34;: {}, \u0026#34;transport\u0026#34;: {}, \u0026#34;routing\u0026#34;: {}, \u0026#34;inbounds\u0026#34;: [] }  outbounds.json  { \u0026#34;outbounds\u0026#34;: [] } 以多配置启动 Xray：\n$ xray run -confdir /etc/xray/confs 这两个配置文件的就等效于合成一起的整配置。当需要修改出口节点，只需要修改 outbounds.json 内容。\n如果需要改编日志 log 的级别，也不需要改 base.json，只需后续增加一个配置：\n debuglog.json  { \u0026#34;log\u0026#34;: { \u0026#34;loglevel\u0026#34;: \u0026#34;debug\u0026#34; } } 启动顺序放置在 base 后，即可输出 debug 级别的日志\n\n数组（[]）  在 json 配置中的inbounds和outbounds是数组结构，他们有特殊的规则：\n 当配置中的数组元素有 2 或以上，覆盖前者的 inbounds/oubounds； 当配置中的数组元素只有 1 个时，查找原有tag相同的元素进行覆盖；若无法找到：  对于 inbounds，添加至最后（inbounds 内元素顺序无关） 对于 outbounds，添加至最前（outbounds 默认首选出口）；但如果文件名含有 tail（大小写均可），添加至最后。    借助多配置，可以很方便为原有的配置添加不同协议的 inbound，而不必修改原有配置。\n以下例子不是有效配置，只为展示上述规则。\n 000.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 1234 } ] }  001.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] }  002.json  { \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 } ] } 三个配置将会合成为：\n{ \u0026#34;inbounds\u0026#34;: [ { \u0026#34;protocol\u0026#34;: \u0026#34;socks\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;socks\u0026#34;, \u0026#34;port\u0026#34;: 4321 // \u0026lt;--- 002顺序在000后，因此覆盖tag为socks的inbound端口为4321 }, { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;http\u0026#34; } ] } \n推荐的多文件列表  执行：\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/etc/Xray/$BASE.json\u0026#34;; done 或\nfor BASE in 00_log 01_api 02_dns 03_routing 04_policy 05_inbounds 06_outbounds 07_transport 08_stats 09_reverse; do echo \u0026#39;{}\u0026#39; \u0026gt; \u0026#34;/usr/local/etc/Xray/$BASE.json\u0026#34;; done . ├── 00_log.json ├── 01_api.json ├── 02_dns.json ├── 03_routing.json ├── 04_policy.json ├── 05_inbounds.json ├── 06_outbounds.json ├── 07_transport.json ├── 08_stats.json └── 09_reverse.json 0 directories, 10 files "},{"uri":"https://xtls.github.io/en/","title":"","tags":[],"description":"","content":"\n  \n\n不 畏 浮 云 遮 望 眼 · 金 睛 如 炬 耀 苍 穹  不 畏 浮 云 遮 望 眼 金 睛 如 炬 耀 苍 穹  K E E P \u0026nbsp; R I D I N G \u0026nbsp; / \u0026nbsp; N E V E R \u0026nbsp; L O O K \u0026nbsp; B A C K  K E E P \u0026nbsp; R I D I N G \u0026nbsp; N E V E R \u0026nbsp; L O O K \u0026nbsp; B A C K   START HERE  \n  Designed for Speed VLESS: an Original Lightweight Proxy Protocol, Zero Redundant Encryption Overhead.\nXTLS: Standard TLS Encryption with Kernel-level Packet Flow Control Optimization, Powered by VLESS.\n Versatile Fallbacks One-to-Many Port Sharing: Common Server Ports (like 443) Can Be Shared by Multiple Backends\nInvisible Proxy Service: Normalized Server Responses. Effective Against Active Probing.\n Privacy Protection Tracking Prevention: Block AD Networks and Tracking Sites based on Community Blocklist\nDomain Filtering: Customize Your Traffic Filtering at Domain Level, with built-in RegEx Support\n Compatibility Chipset Supported: x86, amd64, ARM, Apple Silicon and more\u0026hellip;\nOS Supported: Windows, macOS, Linux, iOS, Android and more\u0026hellip;\n Hardware Friendly Simple Maintenance: Single Binary Deployment\nAffordable Hardware Ready: Raspberry Pi, OpenWRT and more\u0026hellip;\n Open Community Active and Friendly As Core Community Value\nOpen Source - MPL 2.0 License\n   \n\n"},{"uri":"https://xtls.github.io/en/404.html","title":"Whoops! Page not found","tags":[],"description":"This is a 404 page","content":"That page can\u0026rsquo;t be found.\nOur latest content is on the homepage.\nPhoto by Aron Visuals on Unsplash"}]